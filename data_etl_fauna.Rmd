---
title: "Data ETL: Fauna"
author: "Florian Mayer, DBCA"
date: "`r Sys.time()`"
always_allow_html: yes
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    fig_width: 10
    fig_height: 6
    code_folding: hide
    theme: lumen
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = TRUE)
source("helpers.R")
```
# Context
[Fauna dataset](https://data.dpaw.wa.gov.au/dataset/threatened-and-priority-fauna-database) 
on the [departmental data catalogue](https://data.dpaw.wa.gov.au/).

The code for all SCB workbooks is under version control at [github](https://github.com/dbca-wa/scarab-scripts).

# Data
The zip archive containing the MS Access database is downloaded from the data 
catalogue, the archive is extracted, and a database connection is opened.

```{r fauna_data_load, message=FALSE}
fauna_data <- dl_mdbzip("66efb68d-8f05-4bfc-af14-5d1a381d0cf2")
```

# Lookup tables
Lookup table columns are renamed to facilitate joining.

```{r lookup_tables}
# Lookup tables
shires <- fauna_data$Shires %>%
  dplyr::transmute(
    lga_id = LGACode %>% as.integer(),
    shire_name = LGAName %>% as.character(),
    shire_label = LGAName2 %>% as.character()
  )

tenure <- fauna_data$`Land Tenure` %>%
  dplyr::transmute(
    tenure_id = TenCode %>% as.character(),
    tenure = Tenure %>% as.character()
  )

vegetation_types <- fauna_data$`Vegetation Types` %>%
  dplyr::mutate(
    vegetation_type_id = VegCode %>% as.character(),
    vegetation_type = VegTypeName %>% as.character()
  )

certainty <- fauna_data$Certainty %>%
  dplyr::transmute(
    certainty_id = Code %>% as.integer(),
    certainty = Certainty %>% as.character()
  )

users <- tibble::tibble(
  username = c(
    "AmyM", "AbbyT", "BrianaWingfield",
    "ChristineFreegard", "GeorginaA", "KellieMantle",
    "NickyMarlow", "PeterMawson", "PeterOrell"
  ),
  initials = c(
    "AM", "AT", "BW",
    "CF", "GA", "KM",
    "NM", "PM", "PO"
  ),
  name = c(
    "Amy Mutton", "Abby Thomas", "Briana Wingfield",
    "Christine Freegard", "Georgina Anderson", "Kellie Mantle",
    "Nicky Marlow", "Peter Mawson", "Peter Orell"
  )
)

phylo_class <- fauna_data$`Class List` %>%
  dplyr::transmute(
    phylo_class_id = ClassCode %>% as.character(),
    phylo_class_common_name = ClassName %>% as.character(),
    phylo_class_scientific_name = Class %>% as.character(),
    order = ClassOrder %>% as.character()
  ) %>%
  dplyr::arrange(order)

phylo_group <- fauna_data$`Group List` %>%
  dplyr::transmute(
    phylo_group_id = Group %>% as.integer(),
    phylo_group_name = GroupName %>% as.character(),
    phylo_class_id = Class %>% as.character()
    # order = GroupOrder %>% as.character()
  ) %>%
  dplyr::left_join(phylo_class, by = "phylo_class_id")
# skimr::skim(group)

species_notes <- fauna_data$`Species Notes` %>%
  dplyr::transmute(
    species_code = SpCode %>% as.character(),
    species_notes = Notes %>% as.character()
  )

resolution <- fauna_data$Resolution %>%
  dplyr::transmute(
    resolution_id = ResCode %>% as.integer(),
    resolution_geographic_coords = ResolutionLL %>% as.character(),
    resolution_projected_coords = ResolutionUTM %>% as.character()
  )

resolution_m <- tibble::tibble(
    resolution_id = c(1,2,3,4,5,6),
    accuracy = c(50,100,1000, 10000, 50000, 100000)
)

category <- fauna_data$`Category List` %>%
  dplyr::transmute(
    category_id = Category %>% as.character(),
    phylogenetic_category = CategoryName %>% as.character()
  )
```

# Taxonomy
Data is parsed into matching data types, dates are recognised, and lookup
values are joined while lookup IDs are retained to facilitate later data ingestion
into other systems.

Legacy column names are capitalised, while new or reformatted column are lower-cased.

```{r fauna_species}
# TODO species notes
species <- fauna_data$`Species List` %>%
  dplyr::transmute(
    species_code = SpCode %>% as.character(),
    old_species_code = OldCode %>% as.character(),
    short_code = ShCode %>% as.character(),
    name_id = NameID %>% as.character(),
    scientific_name = ScName %>% as.character(),
    common_name = ComName %>% as.character(),
    phylo_group_id = PhyloGroup %>% as.integer(),
    family = Family %>% as.character(),
    genus = Genus %>% as.character(),
    species = Species %>% as.character(),
    authority_species = Authority.sp %>% as.character(),
    subspecies = Subspecies %>% as.character(),
    authority_subspecies = Authority.ssp %>% as.character(),
    # file_number_calm = CALMFileNum %>%
    #   as.character() %>%
    #   map(~ as_filenumber(., prefix = "CALM")),
    # file_number_dec = DECFileNum %>%
    #   as.character() %>%
    #   map(~ as_filenumber(., prefix = "DEC")),
    # file_number_dpaw = DPaWFileNum %>%
    #   as.character() %>%
    #   map(~ as_filenumber(., prefix = "DPAW")),
    # file_number_dbca = DBCAFileNum %>%
    #   as.character() %>%
    #   map(~ as_filenumber(., prefix = "DBCA")),
    category_id = Category %>% as.character(),
    origin = Origin %>% as.character(), # N - native, I - introduced
    # region_id_list = Region %>% map(~ as.list(strsplit(., ",")[[1]] %>% as.integer())),
    taxon_id = TaxonId %>% as.logical()
    # translocated = Trans %>% as.character(), # E - extant, T - translocated
    # accept_new_records = Incl %>% as.logical(), # only FALSE in old records
    # species_can_be_trapped = Trap %>% as.logical(),
    # only_sighting_type_surveys = Sight %>% as.logical(),
    # could_have_nest_box = Nbox %>% as.### Datalogical(),
    # could_display_secondary_signs = Sign %>% as.logical(),
    # can_associate_band_number = BANo %>% as.logical(),
    # buffer = Buffer %>% as.character(), # NA 0 1 2 3 - unused
    # estimated_lifespan = EST.LIFE %>% as.integer() # NA  0 10  7 15  6  8
  ) %>%
  dplyr::left_join(phylo_group, by = "phylo_group_id") %>%
  dplyr::left_join(species_notes, by = "species_code") %>%
  dplyr::left_join(category, by = "category_id")
species_skim <- skimr::skim(species)
# print(species_skim)
DT::datatable(species)

# Just the essentials: species code, name_id, names.
species_names <- species %>%
  dplyr::select(species_code, name_id, scientific_name, common_name)

# Without things that break saving to CSV
species_save <- species %>% dplyr::select(-starts_with("file_number"))
```

The table `species` contains info on:

* taxonomy (links to `name_id`, names, various hierarchy levels, 
  paraphyletic groups e.g. `phylo_group`, category)
* occurrence summary (e.g. region ID list, an unimplemented m2m relation)
* some numeric fields: `est_life` `r unique(species$est_life)`
* corporate file numbers (what's in those files?)
* some now unused fields (see above for excluded fields)

The field `region_id_list` should be a many-to-many relation to regions, 
but is superseded by spatial lookup of occurrence to spatial entity.

## Taxonomy masterlist: WACensus
The current list of authoritative names resides in WACensus and is published
through OIM's GeoServer.

```{r list_names}
wace_names <- "public:herbie_hbvnames_public" %>% 
    gs_getFeature() %>% 
    magrittr::extract2("features") %>% 
    {tibble::tibble(
        name_id = purrr::map(., c("properties", "name_id")) %>% flatten_chr(),
        wace_name = purrr::map(., c("properties", "name")) %>% flatten_chr()
    )}

species_nid <- species %>% dplyr::left_join(wace_names, by="name_id")
species_name <- species %>% dplyr::left_join(wace_names, by=c("scientific_name" = "wace_name"))
```

## QA: Phrase names
Names with `name_id` 0 are phrase names. These should be entered into WACensus and their resulting
new `name_id` should be backfilled here.

```{r phrase_names}
species %>% 
    filter(name_id == 0) %>% 
    arrange(order) %>% 
    select(species_code, short_code, scientific_name) %>% 
    DT::datatable()
```

## QA: Phrase names in WACensus
Some phrase names may already have been added to WACensus, requiring TFA to update the NameID.

```{r phrase_names_wace}
species %>% 
    dplyr::filter(name_id == 0) %>% 
    dplyr::left_join(wace_names, by=c("scientific_name" = "wace_name")) %>% 
    DT::datatable()
```

## QA: Missing NameID
Names in TFA are matched via NameID to WACensus taxa.

The following list requires a NameID to be found from WACensus 
(e.g. via [TSC's species list](https://tsc.dbca.wa.gov.au/species/)) 
and to be populated in TFA.

```{r missing_nameid}
species %>% 
    filter(is.na(name_id)) %>% 
    arrange(order) %>% 
    select(species_code, short_code, scientific_name) %>% 
    DT::datatable()
```

## QA: Name mismatches
For a given NameID, the scientific name in TFA should be identical to 
the scientific name in WACensus with the same NameID. 
A name mismatch is an indication for review.

```{r wacensus_name_mismatch}
name_mismatches <- species_nid %>% 
    dplyr::filter(scientific_name != wace_name) %>% 
    dplyr::select(name_id, species_code, short_code, scientific_name, wace_name)
```

### Mismatches containing "subsp"
WACensus names contain "subsp." whereas TFA don't. 
Therefore, scientific name mismatches by only the "subsp" can be ignored.

**QA** Review this list to make sure both WACensus and TFA mean the same name.
If the TFA "scientific_name" means a different taxon than the "wace_name", TFA's
NameID must be changed to the WACensus NameID of the correct taxon.

```{r name_mismatches_subsp}
name_mismatches %>% dplyr::filter(grepl('subsp', wace_name)) %>% DT::datatable()
```

### Remaining mismatches
The remaining mismatches contain minor differences, such as "sp." vs "sp", parentheses and quotation marks.

```{r name_mismatches_typo}
name_mismatches %>% dplyr::filter(!grepl('subsp', wace_name)) %>% DT::datatable()
```

### Remaining mismatches
The remaining mismatches require a review of the scientific name or NameID in TFA.

**QA** If the TFA "scientific_name" is meant to refer to a different taxon than the "wace_name", 
TFA's NameID must be changed to the WACensus NameID of the correct taxon.

```{r name_mismatches_real}
drop_cruft <- . %>% stringr::str_remove_all("[.()'\"]|sp|subsp") %>% stringr::str_replace_all("  ", " ")
true_mismatches <- species_nid %>% 
    dplyr::mutate(
        scientific_name = scientific_name %>% drop_cruft,
        wace_name = wace_name %>% drop_cruft
    ) %>% 
    dplyr::filter(scientific_name != wace_name) %>% 
    dplyr::select(name_id, species_code, short_code, scientific_name, wace_name)

true_mismatches %>% DT::datatable()
```


# Occurrence
## Critical Habitat, Population, Subpopulation
* CH are Multipolygon Features.
* Population is the sum of all subpopulations.
* Subpopulation is a spatially and/or genetically distinct group of occurrences.

## Occurrences
* AnimalEncounters are species occurrences.
* Opportunistic sightings by members of public currently end up in ThrFaunaDB.
* Opportunistic sightings by members of public could come in via an app.
* Data returns from wildlife licenses go into the Wildlife Licensing System.
* The precursor of Wildlife Licensing System is a system called "Fauna Survey Return System", which is shown as layer in NatureMap.
* Staff should (but don't always) use the Wildlife Licensing System for data returns.
* Some staff use FaunaFile for data returns.
* Staff could use BioSys for data returns.

```{r fauna_occ}
# Generate column config:
# fauna_data$`Fauna Records` %>% make_coldef()

fauna_raw <- fauna_data$`Fauna Records`
fauna_occ <- fauna_raw %>%
  dplyr::transmute(
    id = DBNo %>% as.integer(),
    # district_db = DistDB %>% as.integer(),
    # district_db_no = DistDBNo %>% as.character(),
    species_code = SpCode %>% as.character(),
    # name_id = NameId %>% as.character(), # they're all NA
    orig_date = Date,
    orig_time = Time,
    o_date = ifelse(
        Date == "",
        default_date, 
        lubridate::parse_date_time2(Date, orders, tz = tz, cutoff_2000 = 18L)
        ) %>% lubridate::as_datetime(.) %>% with_tz(tzone = tz), 
    o_time = ifelse(
        Time == "",
        default_date,
        lubridate::parse_date_time2(Time, orders, tz = tz, cutoff_2000 = 18L)
        ) %>% lubridate::as_datetime(.) %>% with_tz(tzone = tz),
    datetime = ifelse(
        is.na(o_date),
        default_date,
        ifelse(
            is.na(o_time),
            o_date,
            o_date + hours(hour(o_time)) + minutes(minute(o_time))
        )) %>% lubridate::as_datetime(.) %>% with_tz(tzone = tz),
    observer_name = Observer %>% as.character(),
    observer_role = OrgRole %>% as.character(),
    observer_address = Address %>% as.character(),
    observer_phone = Phone %>% as.character(),
    certainty_id = Certainty %>% as.integer(),
    number_seen = NumSeen %>% as.integer(), # sum of number_*
    animal_features = Features %>% as.character(),
    number_adult_males = AdultM %>% as.integer(),
    number_adult_females = AdultF %>% as.integer(),
    number_adult_unknown = AdultU %>% as.integer(),
    number_juvenile_males = JuvM %>% as.integer(),
    number_juvenile_females = JuvF %>% as.integer(),
    number_juvenile_unknown = JuvU %>% as.integer(),
    location_id = Location. %>% as.character(),
    location_name = LocName %>% as.character(),
    tenure_id = TenCode %>% as.character(),
    lga_id = LGACode %>% as.integer(),
    district_id = DistrictNo %>% as.character(),
    site_comment = Site %>% as.character(),
    latitude = Lat %>% as.double(),
    longitude = Long %>% as.double(),
    zone = MapZone %>% as.character(),
    northing = SightNorth %>% as.character(),
    easting = SightEast %>% as.character(),
    datum = Datum %>% as.character(),
    resolution_id = Resolution %>% as.integer(),
    landform_id = Landform %>% as.character(),
    vegetation_type_id = VegType %>% as.character(),
    fire_history = Fire %>% as.character(),
    associated_flora_species_1 = Sp1 %>% as.character(),
    associated_flora_species_2 = Sp2 %>% as.character(),
    associated_flora_species_3 = Sp3 %>% as.character(),
    associated_flora_species_4 = Sp4 %>% as.character(),
    associated_flora_species_5 = Sp5 %>% as.character(),
    associated_flora_species_6 = Sp6 %>% as.character(),
    observation_method = ObservMethod %>% as.character(),
    observation_type = ObservType %>% as.character(),
    secondary_signs = SecSign %>% as.character(),
    observation_comments = Observation %>% as.character(),
    breeding_status = Breeding %>% as.character(),
    specimen_status = Specimen %>% as.character(),
    species_id_confirmed_by = Identification %>% as.character(),
    map_provided = Map %>% as.character(), # TODO parse bool
    mudmap_provided = MudMap %>% as.character(), # TODO parse bool
    photo_taken = Photo %>% as.character(), # TODO parse bool
    notes = Notes %>% as.character(),
    comments = Comments %>% as.character(),
    entered_by = EnName %>% as.character(),
    entered_on = parse_date_time(EnDate, orders = orders, tz = tz),
    changed_by = ChName %>% as.character(),
    changed_on = parse_date_time(ChDate, orders = orders, tz = tz),
    specimen_voucher_exists = SpVoucher %>% as.logical(),
    specimen_voucher_location = SpHeld %>% as.character(), # specimen catalogue
    specimen_voucher_catalogue_number = SpCatNum %>% as.character(),
    occurence_not_published = UnPublished %>% as.logical(),
    occurrence_citation = ReportTitle %>% as.character(),
    # occurrence_citation_author = Author %>% as.character(),
    malleefowl_MFeggsH = MFeggsH %>% as.character(),
    malleefowl_MFeggsU = MFeggsU %>% as.character(),
    malleefowl_MFmoundU = MFmoundU %>% as.character(),
    malleefowl_MFmoundCA = MFmoundCA %>% as.character(),
    malleefowl_MFmoundRA = MFmoundRA %>% as.character(),
    malleefowl_MFmoundI = MFmoundI %>% as.character(),
    malleefowl_MFMage = MFMage %>% as.character(),
    malleefowl_MFMdiam = MFMdiam %>% as.character(),
    malleefowl_MFMheight = MFMheight %>% as.character(),
    malleefowl_MFMwidth = MFMwidth %>% as.character(),
    malleefowl_MFMdepth = MFMdepth %>% as.character(),
    malleefowl_MFMsoil = MFMsoil %>% as.character(),
    malleefowl_MFMcomment = MFMcomment %>% as.character(),
    malleefowl_MFextract = MFextract %>% as.character()
    # Field* are empty, skipping:
    # Field1 = Field1 %>% as.character(),
    # Field2 = Field2 %>% as.character(),
    # Field3 = Field3 %>% as.character(),
    # Field4 = Field4 %>% as.character(),
    # Field5 = Field5 %>% as.character()
  ) %>%
  dplyr::left_join(shires, by = "lga_id") %>%
  dplyr::left_join(tenure, by = "tenure_id") %>%
  dplyr::left_join(vegetation_types, by = "vegetation_type_id") %>%
  dplyr::left_join(certainty, by = "certainty_id") %>%
  dplyr::left_join(species_names, by = "species_code") %>%
  dplyr::left_join(resolution_m, by = "resolution_id") %>%
  invisible()

# fauna_occ %>% dplyr::filter(name_id == "0")
# %>% dplyr::select(-o_date, -o_time)
```

## Taxonomic caveats
Fauna occurrences link to the name that was current / legal at the time.
Occurrence query should show hints linking to current / legal names and their history.

`zone` and `datum` are standard names expected by BioSys.

## Occurrence data overview
The table `fauna_occ` contains species occurrence records with information about:

* taxonomy,
* location (coordinates, accuracy and derived information) and datetime of observation,
* observers, taxonomic ID confirmation,
* data entry and last change (date and operator),
* info on type specimens,
* info on surroundings of observation,
* info on animal(s) like group size, age, breeding condition,
* additional info (comments, whether photo was taken),
* MalleeFowl-specific observations (MF*),
* empty columns (Field*).

A condensed overview over data values (completeness, ranges and distribution):

```{r fauna_skim, eval=F}
fauna_skim <- fauna_occ %>% skimr::skim()
print(fauna_skim)
```

There are `r nrow(fauna_occ)` species occurrence records (encounters). 
The following columns are incomplete, which may only pose a problem for mandatory columns:

```{r fauna_missing_values, eval=F}
fauna_skim %>%
  filter(stat == "missing", value > 0) %>%
  select(-stat, -level, -formatted) %>%
  DT::datatable(.)
```

## Occurrence data QA
This section lists data issues which need to be fixed at the source (here, in the legacy Fauna DB).

The column `datetime` is required in BioSys to be populated.
R generates `NA` where datetime is missing, but BioSys can't handle `NA` strings.

Where a time is missing, we'll default to midnight (00:00).
Where a date is missing, we'll default to 1900-01-01.

While this modifies the original data, the consequences will not have a dramatic effect on analyses for
conservation management purposes:

* A safe default of the observation time (midnight) could introduce an error of up to one day. 
  Compared to the time frame considered (past 10-50 years of observations relative to time of 
  calculation), this error is minuscule.
* A safe default for missing dates (1900-01-01) will both exclude those observations from any recent
  observations (past 10-50 years), but still make the data available to identify the records for the
  purpose of backfilling a credible date.

Please review legacy data until the following numbers are all zero (or accept default handling):

* `r fauna_occ %>% dplyr::filter(is.na(datetime)) %>% nrow()` datetimes couldn't be restored and require
  a valid date (and ideally time) to be set at the source.
* `r fauna_occ %>% dplyr::filter(orig_time == "") %>% nrow()` records lack an explicit time and were 
  defaulted to midnight AWST.
* `r fauna_occ %>% dplyr::filter(orig_date == "") %>% nrow()` records lack an explicit date and were
  defaulted to 1900-01-01.
* `r fauna_occ %>% dplyr::filter(is.na(latitude)) %>% nrow` latitudes are missing.
* `r fauna_occ %>% dplyr::filter(is.na(longitude)) %>% nrow` longitudes are missing.
* `r fauna_occ %>% dplyr::filter(latitude > 0) %>% nrow` latitudes lack the minus sign and turn up in China.

## Data migration strategy
* Personnel: Create lookup table of `Personnel$Initials` to DBCA usernames as table `users`.
* Names: observer, taxonomist, record entered by, record last changed by.
* Names include members of public.

## Occurrence Map
An interactive map of fauna occurrences.

```{r fauna_map}
leaflet(width = 800, height = 600) %>%
  addProviderTiles("Esri.WorldImagery", group = "Aerial") %>%
  addProviderTiles("OpenStreetMap.Mapnik", group = "Place names") %>%
  clearBounds() %>%
  addAwesomeMarkers(
    data = fauna_occ,
    lng = ~ longitude, lat = ~ latitude,
    icon = leaflet::makeAwesomeIcon(icon = "leaf"),
    label = ~ glue::glue(
        "{scientific_name} ({stringr::str_to_title(common_name)})"
    ),
    popup = ~ glue::glue(
        "<h3>{stringr::str_to_title(common_name)}</h3>
        <strong>{scientific_name}</strong> ({species_code})<br/>
        <strong>Encountered on</strong> {with_tz(datetime, tz=tz)} AWST<br/>
        <strong>by</strong> {observer_name}<br/>
        <strong>through</strong> {observation_method} ({observation_type})<br/>
        <strong>at </strong> {site_comment} ({shire_label})<br/>
        <strong>Tenure</strong> {tenure} ({tenure_id})<br/>
        <strong>Vegetation type</strong> {vegetation_type} ({vegetation_type_id})<br/>
        <strong>Certainty</strong> {certainty} ({certainty})<br/>"
    ),
    group = "Fauna",
    clusterOptions = markerClusterOptions()
  ) %>%
  addLayersControl(
    baseGroups = c("Aerial", "Place names"),
    overlayGroups = c("Fauna"),
    options = layersControlOptions(collapsed = FALSE)
  )
```

# Conservation status
Gazettal, Listing Category, Listing Names, List Names deal with assigning conservation status from 
various legal listings to species.

## Listing Names
Lookups for legal acts.

```{r fauna_conservation_lists}
fauna_conservation_lists <- fauna_data$`Listing Names` %>%
  dplyr::transmute(
    list_code = ListCode %>% as.character(),
    list_name = ListName %>% as.character(),
    list_order = ListOrder %>% as.integer()
  ) %>%
  dplyr::arrange(list_order)
fauna_conservation_lists %>% dplyr::glimpse()
```

## DEC Listing Names
```{r dec_fauna_conservation_lists}
dec_fauna_conservation_lists <- fauna_data$`DEC List Names` %>%
  dplyr::transmute(
    dec_listing_id = DECCode %>% as.character(),
    dec_listing_name = DECList %>% as.character(),
    dec_listing_order = DECOrder %>% as.integer()
  ) %>%
  dplyr::arrange(dec_listing_order)
dec_fauna_conservation_lists %>% skim() 
dec_fauna_conservation_lists %>% dplyr::glimpse()
```

## Conservation status listing
Each act (listing) defines a number of possible conservation statuses.
The table `Listing Category` contains all possible conservation statuses.
Conservation status can be assigned (for a period of time) to a species.

```{r listing_category}
# make_coldef(listing_category)
conservation_categories <- fauna_data$`Listing Category` %>%
  dplyr::transmute(
    list_code = ListCode %>% as.character(),
    category_code = StatCode %>% as.character(),
    category_label = Status %>% as.character(),
    status_expand = StatusExpand %>% as.character(),
    explanations = Explanations %>% as.character(),
    notes = Notes %>% as.character(),
    order = Order %>% as.integer(),
    dec_listing_id = DECCode %>% as.character()
  ) %>%
  dplyr::arrange(order) %>%
  dplyr::left_join(fauna_conservation_lists, by = "list_code") %>%
  dplyr::left_join(dec_fauna_conservation_lists, by = "dec_listing_id")
conservation_categories %>% skim()
conservation_categories %>%
  head(10) %>%
  DT::datatable(.)
```

## TSC Conservation Listing
This is the data we need to map to: conservation lists, categories, and criteria.

### TSC conservation lists

```{r conslist}
conslist <- wastdr::wastd_GET("conservationlist", api_url = prod) %>% 
  magrittr::extract2("response") %>% 
  httr::content() %>% 
  magrittr::extract2("results") %>% 
  {tibble::tibble(
    list_id = purrr::map_int(., "id"),
    list_code = purrr::map_chr(., "code"),
    list_label = purrr::map_chr(., "label"),
    list_description = wastdr::map_chr_hack(., "description"),
    scope_wa = purrr::map_chr(., "scope_wa"),
    scope_cmw = purrr::map_chr(., "scope_cmw"),
    scope_intl = purrr::map_chr(., "scope_intl"),
    scope_species = purrr::map_chr(., "scope_species"),
    scope_communities = purrr::map_chr(., "scope_communities"),
    approval_level = purrr::map_int(., "approval_level")
  )} 
```

### TSC conservation categories
The conservation category serializer writes JSON, not GeoJSON. 
`wastdr` needs a `parse_conservationcategory` parser.

```{r conscat}
conscat <- wastdr::wastd_GET("conservationcategory", api_url = prod) %>% 
  magrittr::extract2("response") %>% 
  httr::content() %>% 
  magrittr::extract2("results") %>% 
  {tibble::tibble(
    id = purrr::map_int(., "id"),
    list_id = purrr::map_int(., "conservation_list"),
    rank = wastdr::map_chr_hack(., "rank"),
    code = purrr::map_chr(., "code"),
    label = purrr::map_chr(., "label"),
    description = wastdr::map_chr_hack(., "description"),
    current = purrr::map_chr(., "current")
  )} %>% 
  dplyr::arrange(list_id, rank) %>% 
  dplyr::left_join(conslist, by = "list_id")
```

### TSC conservation criteria

```{r conscrit}
conscrit <- wastdr::wastd_GET("conservationcriterion", api_url = prod) %>% 
  magrittr::extract2("response") %>% 
  httr::content() %>% 
  magrittr::extract2("results") %>% 
  {tibble::tibble(
    id = purrr::map_int(., "id"),
    list_id = purrr::map_int(., "conservation_list"),
    rank = wastdr::map_chr_hack(., "rank"),
    code = purrr::map_chr(., "code"),
    label = purrr::map_chr(., "label")
  )} %>% 
  dplyr::arrange(list_id, rank) %>% 
  dplyr::left_join(conslist, by = "list_id")
readr::write_csv(conscrit,path = here::here("data","tsc_conscrit.csv"))
```

## TFA Conservation Listing

Conservation listing is the act of assigning a conservation status to a species for a span of time.
Fauna cons listing columns are renamed and joined to species names by species code.

```{r tfa_cons_listing}
fauna_cons_listing <- fauna_data$Gazettal %>%
  dplyr::transmute(
    species_code = SpCode %>% as.character(),
    list_code = ListCode %>% as.character(),
    category_code = StatCode %>% as.character(),
    population = Popn %>% as.character(),
    criteria_code = Reasons %>% as.character(),
    authority = AUTHORITY %>% as.character(),
    gazetted_on = DateList %>% parse_date_time(., orders = orders, tz = tz),
    delisted_on = DateDeList %>% parse_date_time(., orders = orders, tz = tz),
    review_due = DateReview %>% parse_date_time(., orders = orders, tz = tz),
    interim = INTERIM %>% as.character(),
    translocation = TRANSLOCATION %>% as.character(),
    comments = Comments %>% as.character()
  ) %>%
  dplyr::left_join(species_names, by = "species_code") %>% 
  tibble::rowid_to_column("source_id")
fauna_cons_listing %>% skim()
fauna_cons_listing %>% head(10) %>% DT::datatable()
```

```{r compare_tsc_conscrit_listing_to_tfa_conscrit}
tfa_conscrit <- here::here("data", "tfa_conscrit_w_tsc.csv") %>% 
  readr::read_csv(col_types = cols(
  list_code = col_character(),
  tsc_criteria = col_character(),
  criteria_code = col_character(),
  assigned_as = col_character(),
  comments = col_character()
))

setdiff(fauna_cons_listing$criteria_code,tfa_conscrit$criteria_code) 
setdiff(tfa_conscrit$criteria_code,fauna_cons_listing$criteria_code)

fauna_cons_listing_w_tsc<-fauna_cons_listing %>% 
  left_join(tfa_conscrit,by=c("list_code","criteria_code"))
```
There are 152 criteria in the fauna cons listings which do not match a new tsc criteria. 
There are no criteria in the new tsc criteria which do not match a criteria in the fauna cons listings.


Some cons listings have a name_id of 0. These are phrase names and require to be assigned the `name_id`
of the published name.

```{r}
fauna_cons_listing_w_tsc %>% dplyr::filter(name_id == 0)
```

Let's save a snapshot of the cons listings.

```{r tfa_cons_listing_save}
fcl_file <- here::here("data", "fauna_cons_listing_w_tsc.Rdata")
save(fauna_cons_listing_w_tsc, file=fcl_file)
if (file.exists(fcl_file)) load(fcl_file)
```

Conservation lists used in Fauna cons listings:

```{r tfa_cons_listing_qa}
fauna_cons_listing_w_tsc$list_code %>% unique # cons lists used
fauna_cons_listing_w_tsc %>% dplyr::filter(list_code == "WAPF") %>% DT::datatable() # = WAPS
fauna_cons_listing_w_tsc %>% dplyr::filter(list_code == "ActionPlan") %>% DT::datatable() # Discard those?
fauna_cons_listing_w_tsc %>% dplyr::filter(list_code == "") %>% DT::datatable() # Discard those?
fauna_cons_listing_w_tsc %>% dplyr::filter(list_code == "RedList") %>% DT::datatable() # Which IUCN version?

# ETL nightmare fuel: condensed criteria mixed with free text
criteria_requiring_mapping <- fauna_cons_listing %>% 
    dplyr::filter(grepl('[+,;]', criteria_code)) 

criteria_not_requiring_mapping <- fauna_cons_listing %>% 
    dplyr::filter(!grepl('[+,;]', criteria_code)) 

crit_not_map <- criteria_not_requiring_mapping %>% 
  dplyr::group_by(list_code) %>% 
  dplyr::distinct(criteria_code) %>% 
  dplyr::arrange(list_code, criteria_code) %>% 
  dplyr::select(list_code, criteria_code)
  
crit_map <- criteria_requiring_mapping %>% 
  dplyr::group_by(list_code) %>% 
  dplyr::distinct(criteria_code) %>% 
  dplyr::arrange(list_code, criteria_code) %>% 
  dplyr::select(list_code, criteria_code)
readr::write_csv(crit_map, path = here::here("data","tfa_conscrit.csv"))
```

Conservation listings are entered in triplicate:

Level 1: Legislation

* WAWCA is the WA Wildlife Conservation Act, the legistation under which taxa can be gazetted as specially protected.
* WAWCA has been superseded by the Biodiversity Conservation Act 2016 on 01/01/2019.
* All conservation listings were/are gazetted under the respective act (WAWCA or BCA).

Level 2: Gazette

* SPFN = "Wildlife Conservation (Specially Protected Fauna) Notice, Schedules"
* SPFN are the gazetted schedules.

Level 3: Assigned conservation categories and criteria

* DBCA has assigned actual conservation cat&crit to taxa following the IUCN definitions, 
  or similar cat&crit of own design before IUCN was published.
* These "IUCN" cons listings are the actual listings we want to preserve.

In future, only IUCN 2012 cat&crit will be assigned to taxa.
The list of all listed taxa will be published by the government gazette annually, 
which will set the life cycle status of our IUN listings to "gazetted".
The underlying legislation (from now on, the BCA) is evident out of the context 
and does not have to be entered as conservation listing into TSC.

QA questions for Fauna cons listings:

* Fauna WAPF = TSC WAPS = Priority species
* Which TSC IUCN redlist is Fauna RedList?
* Fauna ActionPlan - do we keep this info?
* Fauna has three empty listings (no list, no cat, no crit) - discard?

`r criteria_requiring_mapping %>% nrow` conservation listings contain condensed 
lists of criteria mixed with free text. 
Rather than manually transcribing this number, a manually written mapping for
`r criteria_requiring_mapping$reasons %>% unique %>% length` 
distinct values can be used to  automate ETL.

Note 24 June 2019: Some very new WACensus name IDs (49200 range) are not yet migrated and therefore temporarily excluded here.


```{r tfa_cons_listing_upload, eval=F}
# tsc_conscat$id is the TSC ID for the cons category
# tsc_conscat$label = tec_cons_listing_categories$category_code
tsc_conscat_sp <- "conservationcategory" %>% 
  wastdr::wastd_GET(api_url = prod) %>% 
  magrittr::extract2("response") %>% 
  httr::content(.) %>% 
  magrittr::extract2("results") %>% 
  {tibble::tibble(
    tsc_category_id = purrr::map_int(., "id"),
    category_code = purrr::map_chr(., "code"),
    tsc_label = purrr::map_chr(., "label"),
    conservation_list = purrr::map_chr(., "conservation_list")
  )} %>% 
  dplyr::filter(conservation_list %in% c(1,2,3,4,5,6,7))


# IUCN cons listing
# IUCN 2012 3
tfa_listing_cat_iucn2012 <- fauna_cons_listing_w_tsc %>% 
  dplyr::filter(list_code=="IUCN(2012)") %>% 
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 3), by="category_code") %>% 
  dplyr::transmute(
        source = 1, # TaxonGaz.source TFA
        source_id = source_id %>% as.character(),
        scope = 0,
        status = ifelse(is.na(delisted_on), 80, 90),
        effective_from = gazetted_on,
        effective_to=delisted_on,
        review_due=review_due,
        taxon = name_id %>% as.numeric,
        category = tsc_category_id %>% as.list(),
        criteria = tsc_criteria
    ) %>% 
  dplyr::filter(!is.na(category)) %>% 
  dplyr::filter(taxon!=0)

tfa_listing_cat_iucn2012 %>% 
  wastdr::wastd_POST("taxon-conservationlisting", api_url = uat)
# tfa_listing_cat_iucn2012 %>% 
#   wastdr::wastd_POST("taxon-conservationlisting", api_url = dev)

# IUCN(2001) 4
tfa_listing_cat_iucn2001 <- fauna_cons_listing %>% 
  dplyr::filter(list_code=="IUCN(2001)") %>% 
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 4), by="category_code") %>% 
  dplyr::transmute(
        source = 1, # TaxonGaz.source TFA
        source_id = source_id %>% as.character(),
        scope = 0,
        status = ifelse(is.na(delisted_on), 80, 90),
        effective_from = gazetted_on,
        effective_to=delisted_on,
        review_due=review_due,
        taxon = name_id %>% as.numeric,
        category = tsc_category_id %>% as.list(),
        criteria = 1
    ) %>% 
  dplyr::filter(!is.na(category)) %>% 
  dplyr::filter(taxon!=0)

tfa_listing_cat_iucn2001 %>%
  wastdr::wastd_POST("taxon-conservationlisting", api_url = prod)

# IUCN(1994) 5
tfa_listing_cat_iucn1994 <- fauna_cons_listing %>% 
  dplyr::filter(list_code=="IUCN(1994)") %>% 
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 5), by="category_code") %>% 
  dplyr::transmute(
        source = 1, # TaxonGaz.source TFA
        source_id = source_id %>% as.character(),
        scope = 0,
        status = ifelse(is.na(delisted_on), 80, 90),
        effective_from = gazetted_on,
        effective_to=delisted_on,
        review_due=review_due,
        taxon = name_id %>% as.numeric,
        category = tsc_category_id %>% as.list(),
        criteria = 1
    ) %>% 
  dplyr::filter(!is.na(category)) %>% 
  dplyr::filter(taxon!=0)

tfa_listing_cat_iucn1994 %>%
  # filter(taxon != 49208) %>% 
  # filter(taxon != 49211) %>% 
  wastdr::wastd_POST("taxon-conservationlisting", api_url = prod)


# WAWCA 1
tfa_listing_cat_wawca <- fauna_cons_listing %>% 
  dplyr::filter(list_code=="WAWCA") %>% 
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 1), by="category_code") %>% 
  dplyr::transmute(
        source = 1, # TaxonGaz.source TFA
        source_id = source_id %>% as.character(),
        scope = 0,
        status = ifelse(is.na(delisted_on), 80, 90),
        effective_from = gazetted_on,
        effective_to=delisted_on,
        review_due=review_due,
        taxon = name_id %>% as.numeric,
        category = tsc_category_id %>% as.list(),
        criteria = 1
    ) %>% 
  dplyr::filter(!is.na(category)) %>% 
  dplyr::filter(taxon!=0)

tfa_listing_cat_wawca %>% 
  # filter(taxon != 49208) %>% 
  # filter(taxon != 49210) %>% 
  # filter(taxon != 49211) %>% 
  wastdr::wastd_POST("taxon-conservationlisting", api_url = prod)

# SPFN 2
tfa_listing_cat_spfn <- fauna_cons_listing %>% 
  dplyr::filter(list_code=="SPFN") %>% 
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 2), by="category_code") %>% 
  dplyr::transmute(
        source = 1, # TaxonGaz.source TFA
        source_id = source_id %>% as.character(),
        scope = 0,
        status = ifelse(is.na(delisted_on), 80, 90),
        effective_from = gazetted_on,
        effective_to=delisted_on,
        review_due=review_due,
        taxon = name_id %>% as.numeric,
        category = tsc_category_id %>% as.list(),
        criteria = 1
    ) %>% 
  dplyr::filter(!is.na(category)) %>% 
  dplyr::filter(taxon!=0)

tfa_listing_cat_spfn %>% 
  # filter(taxon != 49208) %>% 
  # filter(taxon != 49210) %>% 
  # filter(taxon != 49211) %>% 
  wastdr::wastd_POST("taxon-conservationlisting", api_url = prod)

# WAPS 6
tfa_listing_cat_waps <- fauna_cons_listing %>% 
  dplyr::filter(list_code=="WAPF") %>% 
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 6), by="category_code") %>% 
  dplyr::transmute(
        source = 1, # TaxonGaz.source TFA
        source_id = source_id %>% as.character(),
        scope = 0,
        status = ifelse(is.na(delisted_on), 80, 90),
        effective_from = gazetted_on,
        effective_to=delisted_on,
        review_due=review_due,
        taxon = name_id %>% as.numeric,
        category = tsc_category_id %>% as.list(),
        criteria = 1
    ) %>% 
  dplyr::filter(!is.na(category)) %>% 
  dplyr::filter(taxon!=0)

tfa_listing_cat_waps %>% 
  # filter(taxon != 49200) %>% 
  # filter(taxon != 49203) %>% 
  # filter(taxon != 49205) %>% 
  # filter(taxon != 49211) %>% 
  # filter(taxon != 49212) %>% 
  wastdr::wastd_POST("taxon-conservationlisting", api_url = prod)

# EPBC 7
tfa_listing_cat_epbc <- fauna_cons_listing %>% 
  dplyr::filter(list_code=="EPBC") %>% 
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 7), by="category_code") %>% 
  dplyr::transmute(
        source = 1, # TaxonGaz.source TFA
        source_id = source_id %>% as.character(),
        scope = 1,
        status = ifelse(is.na(delisted_on), 80, 90),
        effective_from = gazetted_on,
        effective_to=delisted_on,
        review_due=review_due,
        taxon = name_id %>% as.numeric,
        category = tsc_category_id %>% as.list(),
        criteria = 1
    ) %>% 
  dplyr::filter(!is.na(category)) %>% 
  dplyr::filter(taxon!=0)

tfa_listing_cat_epbc %>% 
  filter(taxon != 49211) %>% 
  wastdr::wastd_POST("taxon-conservationlisting", api_url = prod)
```



# Recovery Planning
Recovery Plans, Recovery Actions, Research Topics, Research Priorities.

## Research Priorities
```{r res_prio}
res_prio <- fauna_data$`Research Priorities` %>%
  dplyr::transmute(
    species_code = SpCode %>% as.character(),
    research_priority = ResearchPriority %>% as.character(),
    undertaken = Undertaken %>% as.logical(),
    comments = Comments %>% as.character()
  ) %>%
  left_join(species_names, by = "species_code")
res_prio %>% skim()
```

## Recovery Plans
```{r recovery_plans}
res_topics <- fauna_data$`Research Topics` %>%
  dplyr::transmute(
    research_topic_id = ID %>% as.integer(),
    research_topic = Research.Topics %>% as.character()
  )

rec_actions <- fauna_data$`Recovery Actions` %>%
  dplyr::transmute(
    recovery_action_id = ID %>% as.integer(),
    recovery_action = Recovery.Actions %>% as.character(),
  )

recovery_plans <- fauna_data$`Recovery Plans` %>%
  dplyr::transmute(
    species_code = SpCode %>% as.character(),
    program_number = ProgramNo %>% as.integer(),
    title = RecoveryPlan %>% as.character(),
    scope = NationalorState %>% as.character(),
    year_approved = YearApproved %>% as.character(),
    objectives = Objectives %>% as.character(),
    recovery_action_id = ActionTypes %>% as.integer(),
    research_topic_id = ResearchTopics %>% as.integer(),
    recovery_team = RecoveryTeam %>% as.character(),
    is_active = Active %>% as.logical(),
    team_scope = RTNationalorState %>% as.character(),
    lead_org = LeadOrg %>% as.character(),
    chair_org = ChairOrg %>% as.character(),
    chair_name = ChairName %>% as.character(),
    chair_contact = ChairContact %>% as.character(),
    xo_name = ExecOName %>% as.character(),
    xo_contact = ExecOContact %>% as.character(),
    membership = Membership %>% as.character(),
    rt_filenumber = RTFileNumber %>% as.character()
  ) %>%
  dplyr::left_join(res_topics, by = "research_topic_id") %>%
  dplyr::left_join(rec_actions, by = "recovery_action_id") %>%
  dplyr::left_join(species_names, by = "species_code")
recovery_plans %>% skim()
recovery_plans %>% DT::datatable(.)
```

# Data model
As a relational data model, the dependencies can be expressed linearly 
(excluding key-value lookups):

* [Taxonomy] Species names
* [Observations] Species Occurrence > Species Names
* [Conservation] Conservation List > Conservation Status > fauna_cons_listing > Species names
* [Conservation] Recovery Plan / Conservation Advice > Species Names
* [Conservation] Research Priorities > Species Names
* [Conservation] Threats > Species Names

The models fit broadly into three modules:

* Taxonomy - a local copy of WACensus plus temporary names.
* Observations - encounters with things (such as animals) and related measurements.
* Conservation - conservation status and its assignment to species names, recovery plans aiming to
  change conservation status, research priorities related to species names.

# Data upload
Create resource once-off to get a resource ID.
Subsequently, upload the compiled workbook.
Note, this process lags one compilation of this workbook, as the HTML output
is generated after the R code is run.

```{r fauna_upload, eval=T}
d <- ckanr::package_show("threatened-and-priority-fauna-database")
ckanr::resource_update("761af921-94ad-4383-be2c-300713c37e98", "data_etl_fauna.html")
upload_to_ckan(species_save, "Threatened Fauna Species Names", d$id,
               resource_id = "eae0b480-c687-450c-a736-87d4e75c2a4d")
upload_to_ckan(res_prio, "Threatened Fauna Research Priorities", d$id,
               resource_id = "7a26d00c-f3da-46a3-9d74-42e4475bd6a9")
upload_to_ckan(conservation_categories, "Threatened Fauna Conservation Lists", d$id,
               resource_id = "2793b1a8-eb55-41e7-8f8f-9cbc79a01243")
upload_to_ckan(fauna_cons_listing, "Threatened Fauna Conservation Status Gazettal", d$id,
               resource_id = "ac089664-de5a-4efa-af3c-ada0ec77ef1f")
upload_to_ckan(recovery_plans, "Threatened Fauna Recovery Plans", d$id,
               resource_id = "9f8426c3-20ed-4ba7-a551-05e1838ab1cb")
# Only complete occurrence records are uploaded:
upload_to_ckan(fauna_occ, "Threatened Fauna Occurrence", d$id,
               resource_id = "b73ae0de-f243-4bb3-bbce-25b65bb98e66")
```

