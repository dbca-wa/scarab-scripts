---
title: "Data ETL: Fauna"
author: "Florian Mayer and Milly Piggott, DBCA"
date: "`r Sys.time()`"
always_allow_html: yes
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    fig_width: 10
    fig_height: 6
    code_folding: hide
    theme: lumen
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = TRUE)
source("helpers.R")

# Cached data from TSC - delete to force refresh
tfa_extracted <- here::here("data/tfa_extracted.Rdata")
tfa_transformed <- here::here("data/tfa_transformed.RData")
tfa_occ_datafile <- here::here("data/tfa_occ.Rdata")
tsc_extracted_fauna <- here::here("data/tsc_extracted_fauna.RData")
```

# Context
This workbook summarises the legacy data migration and QA for the Threatened
and Priority Fauna database (TFA) as shown in the following diagram.

The last chapter of this workbook forms the "data migration report", which 
shows whether the data migration was correct, consistent, and comprehensive.

![](https://data.dbca.wa.gov.au/dataset/79e90d7b-33a3-4aa0-8634-8a12033eb21d/resource/98588a4e-b3af-452b-bbf4-f63ca7697752/download/tsc-progress.jpg){width="100%"}

By default, all code blocks are collapsed to provide better readability to the
non-technical audience. Feel free to expand the code blocks to view the process.

The code for all SCB workbooks is under version control at 
[github](https://github.com/dbca-wa/scarab-scripts).

## How to read this workbook
This workbook servers several audiences.

### Data custodians
**Data custodians** are the "daily drivers" of the legacy systems, and will be
the "daily drivers" of TSC.
Data custodians should 

* read this workbook end to end, and be able to understand each section,
* review the summary tables for matching totals of legacy systems vs TSC,
* use the interactive tables for spot checks of individual records.

### Data analysts
**Data analysts** will re-build all legacy reports from TSC's API. Since this
workbook accesses and parses all data from TSC, it thereby supplies working
examples of extracting every bit of TSC data.

Reports follow a common scheme:

* access data from TSC,
* parse data into suitable shape (spreadsheets-like flat tables) and 
  datatypes (e.g. dates, locations),
* filter data as required (date range, regions),
* visualise data as required (pivot tables, maps),
* export data as required (CSV, GeoJSON),
* disseminate report as required (data catalogue, Google Drive).

This workbook shows many examples of the above steps, which then can be 
recombined and adapted by data analysts as required.

### Data engineers
**Data engineers** will ingest other data sources into TSC as required.
This workbook also contains working examples to upload every TSC related data 
using the TSC API.
Future data imports from other sources can recombine and adapt the code in this
workbook for a running start.

# Legacy Data (TFA)

In this section, data from the Threatened Fauna Database (TFA) is downloaded from the 
[TFA dataset](https://data.dpaw.wa.gov.au/dataset/threatened-and-priority-fauna-database) 
on the DBCA data catalogue, then extracted and transformed.

## Taxonomy

This section extracts taxonomic data from TFA. 
This data will later be compared to the taxonomic data from TSC.

```{r tfa_extract}
if (file.exists(tfa_extracted)) {
  load(tfa_extracted)
} else {
  tfa_data <- dl_mdbzip("66efb68d-8f05-4bfc-af14-5d1a381d0cf2", verbose = T)
  snapshot_last_updated <- "66efb68d-8f05-4bfc-af14-5d1a381d0cf2" %>%
    ckanr::resource_show() %>%
    magrittr::extract2("last_modified") %>%
    lubridate::as_datetime() %>%
    lubridate::with_tz("Australia/Perth")
  save(tfa_data, snapshot_last_updated, file=tfa_extracted)
}
```

```{r tfa_transform}
# Lookup tables
shires <- tfa_data$Shires %>%
  dplyr::transmute(
    lga_id = LGACode %>% as.integer(),
    shire_name = LGAName %>% as.character(),
    shire_label = LGAName2 %>% as.character()
  )

tenure <- tfa_data$`Land Tenure` %>%
  dplyr::transmute(
    tenure_id = TenCode %>% as.character(),
    tenure = Tenure %>% as.character()
  )

vegetation_types <- tfa_data$`Vegetation Types` %>%
  dplyr::transmute(
    vegetation_type_id = VegCode %>% as.character(),
    vegetation_type = VegTypeName %>% as.character()
  )

certainty <- tfa_data$Certainty %>%
  dplyr::transmute(
    certainty_id = Code %>% as.integer(),
    certainty = Certainty %>% as.character()
  )

users <- tibble::tibble(
  username = c(
    "AmyM", "AbbyT", "BrianaWingfield",
    "ChristineFreegard", "GeorginaA", "KellieMantle",
    "NickyMarlow", "PeterMawson", "PeterOrell"
  ),
  initials = c(
    "AM", "AT", "BW",
    "CF", "GA", "KM",
    "NM", "PM", "PO"
  ),
  name = c(
    "Amy Mutton", "Abby Thomas", "Briana Wingfield",
    "Christine Freegard", "Georgina Anderson", "Kellie Mantle",
    "Nicky Marlow", "Peter Mawson", "Peter Orell"
  )
)

# Taxonomy
phylo_class <- tfa_data$`Class List` %>%
  dplyr::transmute(
    phylo_class_id = ClassCode %>% as.character(),
    phylo_class_common_name = ClassName %>% as.character(),
    phylo_class_scientific_name = Class %>% as.character(),
    order = ClassOrder %>% as.character()
  ) %>%
  dplyr::arrange(order)

phylo_group <- tfa_data$`Group List` %>%
  dplyr::transmute(
    phylo_group_id = Group %>% as.integer(),
    phylo_group_name = GroupName %>% as.character(),
    phylo_class_id = Class %>% as.character()
    # order = GroupOrder %>% as.character()
  ) %>%
  dplyr::left_join(phylo_class, by = "phylo_class_id")
# skimr::skim(group)

species_notes_with_duplicates <- tfa_data$`Species Notes` %>%
  dplyr::transmute(
    species_code = SpCode %>% as.character(),
    species_notes = Notes %>% as.character()
  )

tfa_species_notes_duplications <- species_notes_with_duplicates %>%
  filter(species_code %in% unique(.[["species_code"]][duplicated(.[["species_code"]])])) 
# two duplicate species_codes- remove from species notes

readr::write_csv(tfa_species_notes_duplications, path = here::here(
  "data", "tfa_species_notes_duplications.csv")
  )

species_notes <- species_notes_with_duplicates %>% 
  distinct(species_code)

category <- tfa_data$`Category List` %>%
  dplyr::transmute(
    category_id = Category %>% as.character(),
    phylogenetic_category = CategoryName %>% as.character()
  )

landform <- tfa_data$`Landform` %>%
  dplyr::transmute(
    Landform_id = LFCode %>% as.character(),
    Landform = Landform %>% as.character()
  )

secondary_signs <- tfa_data$`Secondary Signs` %>% 
  dplyr::transmute(
    sign = Sign %>% as.character()
  )
readr::write_csv(
  secondary_signs, 
  path = here::here("data", "secondary_signs_data.csv")
) 

# TODO species notes
species_with_duplicates <- tfa_data$`Species List` %>%
  dplyr::transmute(
    species_code = SpCode %>% as.character(),
    old_species_code = OldCode %>% as.character(),
    short_code = ShCode %>% as.character(),
    name_id = NameID %>% as.character(),
    scientific_name = ScName %>% as.character(),
    common_name = ComName %>% as.character(),
    phylo_group_id = PhyloGroup %>% as.integer(),
    family = Family %>% as.character(),
    genus = Genus %>% as.character(),
    species = Species %>% as.character(),
    authority_species = Authority.sp %>% as.character(),
    subspecies = Subspecies %>% as.character(),
    authority_subspecies = Authority.ssp %>% as.character(),
    # file_number_calm = CALMFileNum %>%
    #   as.character() %>%
    #   map(~ as_filenumber(., prefix = "CALM")),
    # file_number_dec = DECFileNum %>%
    #   as.character() %>%
    #   map(~ as_filenumber(., prefix = "DEC")),
    # file_number_dpaw = DPaWFileNum %>%
    #   as.character() %>%
    #   map(~ as_filenumber(., prefix = "DPAW")),
    # file_number_dbca = DBCAFileNum %>%
    #   as.character() %>%
    #   map(~ as_filenumber(., prefix = "DBCA")),
    category_id = Category %>% as.character(),
    origin = Origin %>% as.character(), # N - native, I - introduced
    # region_id_list = Region %>% map(~ as.list(strsplit(., ",")[[1]] %>% as.integer())),
    taxon_id = TaxonId %>% as.logical()
    # translocated = Trans %>% as.character(), # E - extant, T - translocated
    # accept_new_records = Incl %>% as.logical(), # only FALSE in old records
    # species_can_be_trapped = Trap %>% as.logical(),
    # only_sighting_type_surveys = Sight %>% as.logical(),
    # could_have_nest_box = Nbox %>% as.### Datalogical(),
    # could_display_secondary_signs = Sign %>% as.logical(),
    # can_associate_band_number = BANo %>% as.logical(),
    # buffer = Buffer %>% as.character(), # NA 0 1 2 3 - unused
    # estimated_lifespan = EST.LIFE %>% as.integer() # NA  0 10  7 15  6  8
  ) %>%
  dplyr::left_join(phylo_group, by = "phylo_group_id") %>%
  dplyr::left_join(species_notes, by = "species_code") %>%
  dplyr::left_join(category, by = "category_id")

# Duplicate name_id's in species_list
tfa_species_list_dup <- species_with_duplicates %>%
  filter(name_id %in% unique(.[["name_id"]][duplicated(.[["name_id"]])])) # one duplicate name_id
readr::write_csv(tfa_species_list_dup, path = here::here("data", "tfa_species_list_duplications.csv"))

# Anti_join duplicate name_id to species_with_duplicates to remove them.
species <- species_with_duplicates %>% 
dplyr::anti_join(tfa_species_list_dup, by = "name_id")
  
# species_skim <- skimr::skim(species)
# print(species_skim)
# DT::datatable(species)

# Just the essentials: species code, name_id, names.
species_names <- species %>%
  dplyr::select(species_code, name_id, scientific_name, common_name)

resolution <- tfa_data$Resolution %>%
  dplyr::transmute(
    resolution_id = ResCode %>% as.integer(),
    resolution_geographic_coords = ResolutionLL %>% as.character(),
    resolution_projected_coords = ResolutionUTM %>% as.character()
  )

resolution_m <- tibble::tibble(
  resolution_id = c(1, 2, 3, 4, 5, 6),
  accuracy = c(50, 100, 1000, 10000, 50000, 100000)
)
```

## Conservation listings
This section extracts conservation listings from TFA.
TFA conservation criteria are exported as CSV spreadsheet for manual mapping
to TSC values.

```{r make_tfa_cl, warning = FALSE}
# TFA conservation lists
tfa_cons_lists <- tfa_data$`Listing Names` %>%
  dplyr::transmute(
    list_code = ListCode %>% as.character(),
    list_name = ListName %>% as.character(),
    list_order = ListOrder %>% as.integer()
  ) %>%
  dplyr::arrange(list_order)

dec_tfa_cons_lists <- tfa_data$`DEC List Names` %>%
  dplyr::transmute(
    dec_listing_id = DECCode %>% as.character(),
    dec_listing_name = DECList %>% as.character(),
    dec_listing_order = DECOrder %>% as.integer()
  ) %>%
  dplyr::arrange(dec_listing_order)
# dec_tfa_cons_lists %>% skim()
# dec_tfa_cons_lists %>% dplyr::glimpse()

# make_coldef(listing_category)
tfa_cons_cat <- tfa_data$`Listing Category` %>%
  dplyr::transmute(
    list_code = ListCode %>% as.character(),
    category_code = StatCode %>% as.character(),
    category_label = Status %>% as.character(),
    status_expand = StatusExpand %>% as.character(),
    explanations = Explanations %>% as.character(),
    notes = Notes %>% as.character(),
    order = Order %>% as.integer(),
    dec_listing_id = DECCode %>% as.character()
  ) %>%
  dplyr::arrange(order) %>%
  dplyr::left_join(tfa_cons_lists, by = "list_code") %>%
  dplyr::left_join(dec_tfa_cons_lists, by = "dec_listing_id")

# TFA taxon conservation listings
tfa_cons_listings <- tfa_data$Gazettal %>%
  dplyr::transmute(
    species_code = SpCode %>% as.character(),
    list_code = ListCode %>% as.character(),
    category_code = StatCode %>% as.character(),
    population = Popn %>% as.character(),
    criteria_code = Reasons %>% as.character(),
    authority = AUTHORITY %>% as.character(),
    gazetted_on = DateList %>% lubridate::as_datetime(.) %>% with_tz(tzone = tz),
    delisted_on = DateDeList %>% lubridate::as_datetime(.) %>% with_tz(tzone = tz),
    last_reviewed_on = DateReview %>% lubridate::as_datetime(.) %>% with_tz(tzone = tz),
    reviewed_by = INTERIM %>% as.character(),
    review_outcome = TRANSLOCATION %>% as.character(),
    comments = Comments %>% as.character()
    ) %>%
  dplyr::left_join(species_names, by = "species_code") %>%
  tibble::rowid_to_column("source_id") %>% 
  dplyr::mutate(source_id = source_id %>% as.character()) 

# tfa_cons_listings %>% skim()
# tfa_cons_listings %>% head(10) %>% DT::datatable()

# Legacy conservation criteria are free text in condensed writing.
# Write to CSV for manual mapping to TSC criteria PKs.
all_crit_map <- tfa_cons_listings %>%
  dplyr::group_by(list_code) %>%
  dplyr::distinct(criteria_code) %>%
  dplyr::arrange(list_code, criteria_code) %>%
  dplyr::select(list_code, criteria_code) %>% 
  ungroup()
readr::write_csv(all_crit_map, path = here::here("data", "all_tfa_conscrit.csv"))
```

## Occurrences
This section extracts TFA occurrences.

The Mallee Fowl occurrence data subset forms a special case. 
It is extracted into a CSV spreadsheet to the 
[Mallee Fowl](https://data.dpaw.wa.gov.au/dataset/79e90d7b-33a3-4aa0-8634-8a12033eb21d/resource/c636bbdd-7926-4c10-8032-6c7fa5a7e318/download/malleefowl_data.csv) resource on the 
data catalogue.

```{r get_tfa_occ, message=FALSE, warning=FALSE}
# Taxon occurrences
tfa_occ <- tfa_data$`Fauna Records` %>% dplyr::transmute(
  id = DBNo %>% as.character(),
  district_db = DistDB %>% as.integer(),
  district_db_no = DistDBNo %>% as.character(),
  species_code = SpCode %>% as.character(),
  # name_id = NameId %>% as.character(), # they're all NA
  orig_date = Date %>% as.character(),
  orig_time = Time %>% as.character(),
  datetime = orig_date %>% parse_as_datetime(),
  observer_name = Observer %>% as.character(),
  observer_role = OrgRole %>% as.character(),
  observer_address = Address %>% as.character(),
  observer_phone = Phone %>% as.character(),
  certainty_id = Certainty %>% as.integer(),
  number_seen = NumSeen %>% as.integer(),
  # sum of number_*
  animal_features = Features %>% as.character(),
  number_adult_males = AdultM %>% as.integer(),
  number_adult_females = AdultF %>% as.integer(),
  number_adult_unknown = AdultU %>% as.integer(),
  number_juvenile_males = JuvM %>% as.integer(),
  number_juvenile_females = JuvF %>% as.integer(),
  number_juvenile_unknown = JuvU %>% as.integer(),
  location_id = Location. %>% as.character(),
  location_name = LocName %>% as.character(),
  tenure_id = TenCode %>% as.character(),
  lga_id = LGACode %>% as.integer(),
  district_id = DistrictNo %>% as.character(),
  site_comment = Site %>% as.character(),
  latitude = Lat %>% as.double(),
  longitude = Long %>% as.double(),
  zone = MapZone %>% as.character(),
  northing = SightNorth %>% as.character(),
  easting = SightEast %>% as.character(),
  datum = Datum %>% as.character(),
  resolution_id = Resolution %>% as.integer(),
  landform_id = Landform %>% as.character(),
  vegetation_type_id = VegType %>% as.character(),
  fire_history = Fire %>% as.character(),
  associated_flora_species_1 = Sp1 %>% as.character(),
  associated_flora_species_2 = Sp2 %>% as.character(),
  associated_flora_species_3 = Sp3 %>% as.character(),
  associated_flora_species_4 = Sp4 %>% as.character(),
  associated_flora_species_5 = Sp5 %>% as.character(),
  associated_flora_species_6 = Sp6 %>% as.character(),
  observation_method = ObservMethod %>% as.character(),
  observation_type = ObservType %>% as.character(),
  secondary_signs = SecSign %>% as.character(),
  observation_comments = Observation %>% as.character(),
  breeding_status = Breeding %>% as.character(),
  specimen_status = Specimen %>% as.character(),
  species_id_confirmed_by = Identification %>% as.character(),
  map_provided = Map %>% as.character(),
  # TODO parse bool
  mudmap_provided = MudMap %>% as.character(),
  # TODO parse bool
  photo_taken = Photo %>% as.character(),
  # TODO parse bool
  notes = Notes %>% as.character(),
  comments = Comments %>% as.character(),
  entered_by = EnName %>% as.character(),
  entered_on = parse_date_time(EnDate, orders = orders, tz = tz),
  changed_by = ChName %>% as.character(),
  changed_on = parse_date_time(ChDate, orders = orders, tz = tz),
  specimen_voucher_exists = SpVoucher %>% as.logical(),
  specimen_voucher_location = SpHeld %>% as.character(),
  # specimen catalogue
  specimen_voucher_catalogue_number = SpCatNum %>% as.character(),
  occurrence_not_published = UnPublished %>% as.logical(),
  occurrence_citation = ReportTitle %>% as.character(),
  occurrence_citation_author = Author %>% as.character(),
  # malleefowl_MFeggsH = MFeggsH %>% as.character(),
  # malleefowl_MFeggsU = MFeggsU %>% as.character(),
  # malleefowl_MFmoundU = MFmoundU %>% as.character(),
  # malleefowl_MFmoundCA = MFmoundCA %>% as.character(),
  # malleefowl_MFmoundRA = MFmoundRA %>% as.character(),
  # malleefowl_MFmoundI = MFmoundI %>% as.character(),
  # malleefowl_MFMage = MFMage %>% as.character(),
  # malleefowl_MFMdiam = MFMdiam %>% as.character(),
  # malleefowl_MFMheight = MFMheight %>% as.character(),
  # malleefowl_MFMwidth = MFMwidth %>% as.character(),
  # malleefowl_MFMdepth = MFMdepth %>% as.character(),
  # malleefowl_MFMsoil = MFMsoil %>% as.character(),
  # malleefowl_MFMcomment = MFMcomment %>% as.character(),
  # malleefowl_MFextract = MFextract %>% as.character()
  # Field* are empty, skipping:
  # Field1 = Field1 %>% as.character(),
  # Field2 = Field2 %>% as.character(),
  # Field3 = Field3 %>% as.character(),
  # Field4 = Field4 %>% as.character(),
  # Field5 = Field5 %>% as.character()
) %>%
  dplyr::left_join(shires, by = "lga_id") %>%
  dplyr::left_join(tenure, by = "tenure_id")%>%
  # ## veg types has duplicates
  dplyr::left_join(vegetation_types, by = "vegetation_type_id") %>%
  dplyr::left_join(certainty, by = "certainty_id") %>%
  dplyr::left_join(species_names, by = "species_code") %>%
  dplyr::left_join(resolution_m, by = "resolution_id") %>%
  invisible()

tfa_occ_dup <- tfa_occ %>%
  filter(id %in% unique(.[["id"]][duplicated(.[["id"]])])) 
# no duplicates now problems have been removed from species_list and species_notes

hab_comp <- tfa_occ %>%
  has_name_id_and_location %>% 
  dplyr::transmute(
    source = 10,
    source_id = id,
    landform_id = landform_id) %>% 
  filter(landform_id != "")

hab_comp %>%
  dplyr::select(landform_id) %>%
  distinct() %>% 
  readr::write_csv(path = here::here("data", "tfa_landcrit.csv"))

veg_class <- tfa_occ %>%
  has_name_id_and_location %>% 
  dplyr::transmute(
    source = 10,
    source_id = id,
    vegetation_code = vegetation_type_id,
    vegetation_type = vegetation_type) %>%  #parse as free text
    filter(vegetation_code != "")

ass_species <- tfa_occ %>%
  has_name_id_and_location %>%
  dplyr::transmute(
    source = 10,
    source_id = id,
    associated_species_1 = associated_flora_species_1,
    associated_species_2 = associated_flora_species_2,
    associated_species_3 = associated_flora_species_3,
    associated_species_4 = associated_flora_species_4,
    associated_species_5 = associated_flora_species_5,
    associated_species_6 = associated_flora_species_6
  ) %>%  #parse as free text
  dplyr::filter(
    associated_species_1 != "" |
      associated_species_2 != "" |
      associated_species_3 != "" |
      associated_species_4 != "" | associated_species_5 != ""
  )
    
anim_obs <- tfa_occ %>%
  has_name_id_and_location %>%
  dplyr::transmute(
    source = 10,
    source_id = id,
    species_id_confidence = certainty,
    observation_details = glue::glue(
        "Number seen: {number_seen};\n",
        "Detection: {observation_method}: {observation_type};\n",
        "Comments: {observation_comments}"), # Card is free text
    distinctive_features = animal_features,
    number_of_adult_males = number_adult_males,
    number_of_adult_females = number_adult_females,
    number_of_adult_unknown = number_adult_unknown,
    number_of_juvenile_males = number_juvenile_males,
    number_of_juvenile_females = number_juvenile_females,
    number_of_juvenile_unknown = number_juvenile_unknown,
    detection_method = observation_type,
    secondary_signs = secondary_signs,
    reproductive_maturity = breeding_status) %>% 
  dplyr::filter(!is.na(species_id_confidence))

anim_obs %>%
  dplyr::select(species_id_confidence) %>%
  distinct() %>% 
  readr::write_csv(path = here::here("data", "tfa_id_conf.csv"))

anim_obs %>%
  dplyr::select(reproductive_maturity) %>%
  distinct() %>% 
  readr::write_csv(path = here::here("data", "tfa_repmat.csv"))

anim_obs %>%
  dplyr::select(secondary_signs) %>%
  distinct() %>% 
  readr::write_csv(path = here::here("data", "tfa_secsign.csv"))

anim_obs %>%
  dplyr::select(detection_method) %>%
  distinct() %>% 
  readr::write_csv(path = here::here("data", "tfa_detmeth.csv"))

phys_sample <- tfa_occ %>%
  has_name_id_and_location %>%
  dplyr::transmute(
    source = 10,
    source_id = id,
    sample_type = specimen_status,
    specimen_voucher_exists = specimen_voucher_exists,
    sample_destination = specimen_voucher_location,
    sample_label = glue::glue(
      "[{specimen_voucher_location}]{specimen_voucher_catalogue_number}"
    )
  ) %>%
  dplyr::filter(specimen_voucher_exists != "FALSE" |
                  sample_destination != "") %>%
  dplyr::filter(specimen_voucher_exists != "FALSE" |
                  sample_destination != "Not retained") %>%
  dplyr::filter(sample_type != "No specimen" |
                  sample_destination != "Not retained") %>%
  dplyr::filter(sample_type != "Unknown" |
                  sample_destination != "Unknown") %>%
  dplyr::filter(sample_type != "Unknown" |
                  sample_destination != "Unknown location")

phys_sample %>%
  dplyr::select(sample_destination) %>%
  distinct() %>% 
  readr::write_csv(path = here::here("data", "tfa_sampdest.csv"))

phys_sample %>%
  dplyr::select(sample_type) %>%
  distinct() %>% 
  readr::write_csv(path = here::here("data", "tfa_samptype.csv"))

## Put Malleefowl in separate csv file and add to data catalogue
malleefowl_data <- tfa_data$`Fauna Records` %>%
  dplyr::transmute(
    id = DBNo %>% as.character(),
    malleefowl_MFeggsH = MFeggsH %>% as.character(),
    malleefowl_MFeggsU = MFeggsU %>% as.character(),
    malleefowl_MFmoundU = MFmoundU %>% as.character(),
    malleefowl_MFmoundCA = MFmoundCA %>% as.character(),
    malleefowl_MFmoundRA = MFmoundRA %>% as.character(),
    malleefowl_MFmoundI = MFmoundI %>% as.character(),
    malleefowl_MFMage = MFMage %>% as.character(),
    malleefowl_MFMdiam = MFMdiam %>% as.character(),
    malleefowl_MFMheight = MFMheight %>% as.character(),
    malleefowl_MFMwidth = MFMwidth %>% as.character(),
    malleefowl_MFMdepth = MFMdepth %>% as.character(),
    malleefowl_MFMsoil = MFMsoil %>% as.character(),
    malleefowl_MFMcomment = MFMcomment %>% as.character(),
    malleefowl_MFextract = MFextract %>% as.character()
  ) %>%
  na.omit() %>%
  dplyr::left_join(tfa_occ, by = "id")
readr::write_csv(malleefowl_data, path = here::here("data", "malleefowl_data.csv"))

# TFA records in Africa
tfa_occ_latlong_outofbounds <- tfa_occ %>% 
  filter(longitude < 96)
readr::write_csv(tfa_occ_latlong_outofbounds, path = here::here("data", "tfa_occ_latlong_wrong.csv"))

# Create taxon area encounter
tfa_tae <- tfa_occ %>%
  has_name_id_and_location %>%
  filter(longitude > 96) %>%
  # dplyr::left_join(taxa, by="name_id") %>% 
  dplyr::transmute(
    taxon = name_id,
    code = location_id,
    name = location_name,
    description = glue::glue(
        "Observer: {observer_name} ({observer_role}) {observer_address} {observer_phone}\n",
        "Species ID confirmation: {species_id_confirmed_by}\n",
        "Specimen voucher exists: {specimen_voucher_exists}\n",
        "Site comments: {site_comment}\n",
        "Curator comments: {comments}\n",
        "District: {district_db} {district_db_no}\n",
        "Shire: {shire_name} {shire_label}\n",
        "Tenure: {tenure}\n",
        "LGA ID: {lga_id}\n",
        "District ID: {district_id}\n",
        "Vegetation type: {vegetation_type}\n",
        "Associated species: {associated_flora_species_1} ",
        "{associated_flora_species_2} {associated_flora_species_3} ",
        "{associated_flora_species_4} {associated_flora_species_5}\n",
        "Fire history: {fire_history}\n",
        "Date entered: {entered_on} {entered_by}\n",
        "Date changed: {changed_on} {changed_by}\n",
        "Not published: {occurrence_not_published}\n",
        "Occurrence citation: {occurrence_citation} {occurrence_citation_author}"
        ),
    source = 10,
    source_id = id %>% as.character(),
    encounter_type = 1, # https://tsc.dbca.wa.gov.au/admin/occurrence/encountertype/1/change/ = opportunistic 
    encountered_on = glue::glue("{datetime}+08:00"),
    encountered_by = 1,
    area_type = 30,
    geolocation_capture_method='gps-point',
    accuracy = accuracy,
    point = glue::glue("SRID=4326;POINT({longitude} {latitude})"),
    # observation_details = glue::glue("{observation_method} {observation_type} {secondary_signs} {observation_comments}")
  ) %>% 
  dplyr::mutate(
    encountered_on = replace(
      encountered_on, 
      encountered_on == "NA+08:00", 
      "1900-01-01 00:00:00+08:00")
  ) %>%
  dplyr::arrange(taxon)

tfa_tae_dup <- tfa_tae %>%
  filter(source_id %in% unique(.[["source_id"]][duplicated(.[["source_id"]])])) 
# no duplicates now problems have been removed from species_list and species_notes

save(tfa_occ, tfa_tae, file=tfa_occ_datafile, compress = "xz")
if (file.exists(tfa_occ_datafile)) load(tfa_occ_datafile)
```

## Occurrence map
The following map shows the occurrence data from TFA.
Occurrences without `name_id` or location are skipped.

```{r tfa_tae_map, eval=F}
tfa_occ_map <- tfa_occ %>% 
  has_name_id_and_location %>% 
  filter(longitude > 96)

leaflet::leaflet(width = 800, height = 600) %>%
  leaflet::addProviderTiles("Esri.WorldImagery", group = "Aerial") %>%
  leaflet::addProviderTiles("OpenStreetMap.Mapnik", group = "Place names") %>%
  leaflet::clearBounds() %>%
  leaflet::addAwesomeMarkers(
    data = tfa_occ_map,
    lng = ~ longitude, lat = ~ latitude,
    icon = leaflet::makeAwesomeIcon(icon = "spider"),
    label = ~ glue::glue("{datetime} [DBNo {id}] {name_id} {location_id} ({location_name})"),
    # popup = ~ glue::glue(
    #     "<h3>{datetime} {name_id} {location_id} ({location_name})</h3>",
    #     "Observer: {observer_name} ({observer_role}) {observer_address} {observer_phone}<br/>",
    #     "Species ID confirmation: {species_id_confirmed_by}<br/>",
    #     "Specimen voucher exists: {specimen_voucher_exists}<br/>",
    #     "Site comments: {site_comment}<br/>",
    #     "Curator comments: {comments}<br/>",
    #     "District: {district_db} {district_db_no}<br/>",
    #     "Shire: {shire_name} {shire_label}<br/>",
    #     "Tenure: {tenure}<br/>",
    #     "LGA ID: {lga_id}<br/>",
    #     "District ID: {district_id}<br/>",
    #     "Vegetation type: {vegetation_type}<br/>",
    #     "Associated species: {associated_flora_species_1} ",
    #     "{associated_flora_species_2} {associated_flora_species_3} ",
    #     "{associated_flora_species_4} {associated_flora_species_5}<br/>",
    #     "Fire history: {fire_history}<br/>",
    #     "Date entered: {entered_on} {entered_by}<br/>",
    #     "Date changed: {changed_on} {changed_by}<br/>",
    #     "Not published: {occurrence_not_published}<br/>",
    #     "Occurrence citation: {occurrence_citation} {occurrence_citation_author}"
    #     ),
    group = "Fauna",
    clusterOptions = leaflet::markerClusterOptions()
  ) %>%
  leaflet::addLayersControl(
    baseGroups = c("Aerial", "Place names"),
    overlayGroups = c("Fauna"),
    options = leaflet::layersControlOptions(collapsed = FALSE)
  )
```

## Recovery Actions and Plans
This section extracts recovery actions and plans, which will be ingested into 
TSC later.

```{r make_tfa_rec}
tfa_act <- tfa_data$`Recovery Actions` %>%
  dplyr::transmute(id = ID %>% as.integer(),
                   actions = Recovery.Actions %>% as.character())

tfa_pla <- tfa_data$`Recovery Plans` %>%
  dplyr::transmute(
    species_code = SpCode %>% as.character(),
    program_no = ProgramNo %>% as.character(),
    recovery_plan = RecoveryPlan %>% as.character(),
    national_state = NationalorState %>% as.character(),
    year_approved = YearApproved %>% as.character(),
    objectives = Objectives %>% as.character(),
    action_types = ActionTypes %>% as.character(),
    research_topics = ResearchTopics %>% as.character(),
    recovery_team = RecoveryTeam %>% as.character(),
    active = Active %>% as.character(),
    rt_national_state = RTNationalorState %>% as.character(),
    lead_org = LeadOrg %>% as.character(),
    chair_org = ChairOrg %>% as.character(),
    chair_name = ChairName %>% as.character(),
    chair_contact = ChairContact %>% as.character(),
    exec_name = ExecOName %>% as.character(),
    exec_contact = ExecOContact %>% as.character(),
    membership = Membership %>% as.character(),
    rt_file_number = RTFileNumber %>% as.character()
  )
```

## Research priorities and topics
This section extracts research priorities and topics, which are not ingested into
TSC.

```{r make_tfa_res}
tfa_resp <- tfa_data$`Research Priorities` %>%
  dplyr::transmute(
    species_code = SpCode %>% as.character(),
    research_priority = ResearchPriority %>% as.character(),
    undertaken = Undertaken %>% as.character(),
    comments = Comments %>% as.character()
  )

tfa_rest <- tfa_data$`Research Topics` %>%
  dplyr::transmute(
    id = ID %>% as.integer(),
    research_topics = Research.Topics %>% as.character()
  )


readr::write_csv(tfa_resp,
                 path = here::here("data", "research_priorities_data.csv"))
readr::write_csv(tfa_rest, 
                 path = here::here("data", "research_topics_data.csv"))
```

```{r savepoint_tfa}
save(
all_crit_map,
anim_fauna,
anim_obs,
ass_species,
category,
certainty,
chunk_post,
dec_tfa_cons_lists,
default_date,
default_date_notime,
dev,
dl_mdbzip,
eoo_polygon,
fix_incomplete_date,
hab_comp,
landform,
lonlat_to_convex_hull,
make_eoo,
malleefowl_data,
orders,
parse_as_datetime,
phylo_class,
phylo_group,
phys_sample,
prod,
resolution,
resolution_m,
secondary_signs,
shires,
snapshot_last_updated,
species,
species_names,
species_notes,
tenure,
tfa_act,
tfa_cons_cat,
tfa_cons_listings,
tfa_cons_lists,
tfa_data,
tfa_extracted,
tfa_occ,
tfa_occ_datafile,
tfa_pla,
tfa_resp,
tfa_rest,
tfa_tae,
tsc_extracted_fauna,
tz,
uat,
upload_file_to_ckan,
upload_to_ckan,
users,
veg_class,
vegetation_types,
wastd_occ_obs_post,
file = tfa_transformed,
compress = "xz"
)
load(tfa_transformed)
```

# Current conservation lists (TSC)

## Conservation criteria

Conservation criteria from TSC are downloaded from the TSC API 
and transformed into a usable format for manual mapping to TFA.

A manual step annotated legacy conservation criteria exported from TFA to 
conservation criteria IDs in TSC in a spreadsheet.

``` {r get_tsc_tcl, message=FALSE}
tsc_conslist <- wastdr::wastd_GET("conservationlist") %>%
   wastdr::wastd_parse() %>% 
  dplyr::select(
    -conservationcategory_set,
    -conservationcriterion_set
  ) %>% 
  dplyr::rename(
    list_id = id,
    list_code = code,
    list_label = label
  )

tsc_conscat <-  wastdr::wastd_GET("conservationcategory") %>%
  wastdr::wastd_parse() %>% 
  dplyr::rename(list_id = conservation_list) %>% 
  dplyr::arrange(list_id, rank) %>% 
  dplyr::left_join(tsc_conslist, by = "list_id")

tsc_conscrit <- wastdr::wastd_GET("conservationcriterion", api_url = prod) %>% 
  wastdr::wastd_parse() %>% 
  dplyr::rename(list_id = conservation_list) %>% 
  dplyr::arrange(list_id, rank) %>% 
  dplyr::left_join(tsc_conslist, by = "list_id")

readr::write_csv(tsc_conscrit, path = here::here("data/tsc_conscrit_fauna.csv"))

# Load manual mapping of TFA cons criteria from CSV file, join to tfa_cons_crit
tfa_conscrit <- here::here("csv/tfa_conscrit_w_tsc.csv") %>%
  readr::read_csv(
    col_types = cols(
      list_code = col_character(),
      tsc_criteria = col_character(),
      criteria_code = col_character(),
      assigned_as_in_tsc = col_character(),
      comments_MP = col_character(),
      actions = col_character()
    )
  ) %>%
  base::replace(., is.na(.), "") %>% 
  dplyr::mutate(
    tsc_criteria = purrr::map(tsc_criteria, chr2int)
  )

tfa_tcl <- tfa_cons_listings %>%
  left_join(tfa_conscrit, by = c("list_code", "criteria_code"))  %>% 
  # base::replace(., is.na(.), "") %>%
  invisible()
```

## Observation Groups
Occurrence lookups from TSC are downloaded from the TSC API 
and transformed into a usable format for manual mapping to TFA.

A manual step annotated lookups exported from TSC to 
occurrence data in TFA in a spreadsheet.

``` {r get_tsc_occ_lookups, message=FALSE}
tsc_landforms <- wastdr::wastd_GET("lookup-landform") %>%
  wastdr::wastd_parse() %>% 
  dplyr::rename(
    list_id = id,
    list_code = code,
    list_label = label
  ) %>%
  readr::write_csv(path = here::here("data", "tsc_landforms.csv"))

tsc_confidence <- wastdr::wastd_GET("lookup-confidence") %>%
  wastdr::wastd_parse() %>% 
  dplyr::rename(
    list_id = id,
    list_code = code,
    list_label = label
  ) %>%
  readr::write_csv(path = here::here("data", "tsc_confidence.csv"))
  
tsc_repro_mat <- wastdr::wastd_GET("lookup-reproductivematurity") %>%
  wastdr::wastd_parse() %>%
  dplyr::rename(
    list_id = id,
    list_code = code,
    list_label = label
  ) %>%
  readr::write_csv(path = here::here("data", "tsc_repro_mat.csv"))

tsc_sec_signs <- wastdr::wastd_GET("lookup-secondarysigns") %>%
  wastdr::wastd_parse() %>% 
  dplyr::rename(
    list_id = id,
    list_code = code,
    list_label = label
  ) %>%
  readr::write_csv(path = here::here("data", "tsc_sec_signs.csv"))

tsc_samp_dest <- wastdr::wastd_GET("lookup-sampledestination") %>%
  wastdr::wastd_parse() %>%
  dplyr::rename(
    list_id = id,
    list_code = code,
    list_label = label
  ) %>%
  readr::write_csv(path = here::here("data", "tsc_samp_dest.csv"))

tsc_samp_type <- wastdr::wastd_GET("lookup-sampletype") %>%
  wastdr::wastd_parse() %>%
  dplyr::rename(
    list_id = id,
    list_code = code,
    list_label = label
  ) %>%
  readr::write_csv(path = here::here("data", "tsc_samp_type.csv"))

tsc_det_meth <- wastdr::wastd_GET("lookup-detectionmethod") %>%
  wastdr::wastd_parse() %>%
  dplyr::rename(
    list_id = id,
    list_code = code,
    list_label = label
  ) %>%
  readr::write_csv(path = here::here("data", "tsc_det_meth.csv"))

# Load manual mapping of TFA lookup criteria from CSV file, and join to relevant table

# Habitat composition
tfa_landcrit <- here::here("csv/tfa_landcrit_w_tsc.csv") %>%
  readr::read_csv(
    col_types = cols(
      landform_id = col_character(),
      landform = col_character(),
      tsc_landform_id = col_character(),
      tsc_criteria = col_character()
    ))

tfa_hab_comp_complete <- hab_comp %>%
  left_join(tfa_landcrit, by = c("landform_id")) %>%
  dplyr::select(source, source_id, tsc_landform_id) %>%
  dplyr::rename(landform = tsc_landform_id) %>% 
  base::replace(., is.na(.), "") %>% 
  invisible()

# Animal observations
tfa_confidence <- here::here("csv/tfa_id_conf_w_tsc.csv") %>%
  readr::read_csv(
    col_types = cols(
      species_id_confidence = col_character(),
      tsc_species_id_confidence = col_character(),
      tsc_criteria = col_character()
    ))

tfa_det_meth <- here::here("csv/tfa_detmeth_w_tsc.csv") %>%
  readr::read_csv(
    col_types = cols(
      detection_method = col_character(),
      tsc_detection_method = col_character(),
      tsc_criteria = col_character()
    ))

tfa_sec_sign <- here::here("csv/tfa_secsign_w_tsc.csv") %>%
  readr::read_csv(
    col_types = cols(
      secondary_signs = col_character(),
      tsc_secondary_signs = col_character(),
      tsc_criteria = col_character()
    ))

tfa_repmap <- here::here("csv/tfa_repmat_w_tsc.csv") %>%
  readr::read_csv(
    col_types = cols(
      reproductive_maturity = col_character(),
      tsc_reproductive_maturity = col_character(),
      tsc_criteria = col_character()
    ))

tfa_anim_obs_complete <- anim_obs %>%
  left_join(tfa_confidence, by = c("species_id_confidence")) %>%
  left_join(tfa_det_meth, by = c("detection_method")) %>%
  left_join(tfa_sec_sign, by = c("secondary_signs")) %>%
  left_join(tfa_repmap, by = c("reproductive_maturity")) %>%
  dplyr::transmute(
    source = source,
    source_id = source_id,
    species_id_confidence = tsc_species_id_confidence,
    observation_details = observation_details,
    detection_method = tsc_detection_method,
    maturity = tsc_reproductive_maturity,
    secondary_signs = tsc_secondary_signs %>% as.list(), # TSC expects list
    distinctive_features = distinctive_features,
    no_adult_male = number_of_adult_males,
    no_adult_female = number_of_adult_females,
    no_adult_unknown = number_of_adult_unknown,
    no_juvenile_male = number_of_juvenile_males,
    no_juvenile_female =  number_of_juvenile_females,
    no_juvenile_unknown = number_of_juvenile_unknown,
  ) %>% 
  # base::replace(., is.na(.), "") %>% 
  invisible()

# Associated species
tfa_ass_species_complete <- ass_species %>% 
  base::replace(., is.na(.), "") %>% 
  invisible()

# Physical sample
tfa_samptype <- here::here("csv/tfa_samptype_w_tsc.csv") %>%
  readr::read_csv(
    col_types = cols(
      sample_type = col_character(),
      tsc_sample_type = col_character(),
      tsc_criteria = col_character()
    ))

tfa_sampdest <- here::here("csv/tfa_sampdest_w_tsc.csv") %>%
  readr::read_csv(
    col_types = cols(
      sample_destination = col_character(),
      tsc_sample_destination = col_character(),
      tsc_criteria = col_character()
    ))

tfa_phys_sample_complete <- phys_sample %>%
  left_join(tfa_samptype, by = c("sample_type")) %>%
  left_join(tfa_sampdest, by = c("sample_destination")) %>%
  dplyr::transmute(
    source = source,
    source_id = source_id,
    sample_type = tsc_sample_type,
    # specimen_voucher_exists,
    sample_destination = tsc_sample_destination,
    sample_label = sample_label,
    permit_type = NA
  ) %>% 
  base::replace(., is.na(.), "") %>% 
  invisible()

# Vegetation classification 
tfa_veg_class_complete <- veg_class %>% 
  dplyr::transmute(
    source = source,
    source_id = source_id,
    level1 = glue::glue(
      "{vegetation_code}; {vegetation_type}")
    ) %>% 
  base::replace(., is.na(.), "") %>% 
  invisible()

## Check for occ_observations with no matching tae
missing_tae_phys_sample <- tfa_phys_sample_complete %>% 
  dplyr::anti_join(tfa_tae, by = "source_id") #0
missing_tae_anim_obs <- tfa_anim_obs_complete %>% 
  dplyr::anti_join(tfa_tae, by = "source_id")  #2 source_id = 140172, 140215
missing_tae_veg_class <- tfa_veg_class_complete %>% 
  dplyr::anti_join(tfa_tae, by = "source_id") #2 source_id = 140172, 140215
missing_tae_hab_comp <- tfa_hab_comp_complete %>% 
  dplyr::anti_join(tfa_tae, by = "source_id")#1 source_id = 140215

## Remove source_id's with no matching tae
tfa_phys_sample <- tfa_phys_sample_complete %>% 
  dplyr::anti_join(missing_tae_phys_sample, by = "source_id")
tfa_anim_obs <- tfa_anim_obs_complete %>% 
  dplyr::anti_join(missing_tae_anim_obs, by = "source_id")
tfa_veg_class <- tfa_veg_class_complete %>% 
  dplyr::anti_join(missing_tae_veg_class, by = "source_id")
tfa_hab_comp <- tfa_hab_comp_complete %>% 
  dplyr::anti_join(missing_tae_hab_comp, by = "source_id")

# TODO tidyr::drop_na() where level1 is NA
```

# Migrate legacy data (TFL to TSC)

In this section, the extracted and transformed data from TFA are loaded into TSC
using the TSC API. The code is collapsed; expand the code blocks to view the 
process.

## Taxonomy

The QA part of this workbook will compare TFA names to TSC names.

## Conservation listings

```{r make_tfa_tcl, message=FALSE}
tsc_conscat_sp <- "conservationcategory" %>% 
  wastdr::wastd_GET() %>% 
  wastdr::wastd_parse() %>% 
  dplyr::rename(
    tsc_category_id = id,
    category_code = code,
    tsc_label = label
  ) %>% 
  dplyr::filter(conservation_list %in% c(1:7))

# IUCN 2012 3
tfa_listing_cat_iucn2012 <- tfa_tcl %>%
  dplyr::filter(list_code == "IUCN(2012)") %>%
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 3),
    by = "category_code"
  ) %>%
  dplyr::transmute(
    source = 1, # TaxonGaz.source TFA
    source_id = source_id %>% as.character(),
    scope = 0,
    status = ifelse(is.na(delisted_on), 80, 90),
    effective_from = gazetted_on,
    effective_to = delisted_on,
    last_reviewed_on = last_reviewed_on,
    taxon = name_id %>% as.numeric(),
    category = tsc_category_id,
    criteria = tsc_criteria,
    comments = glue::glue(
      "Reviewed by {reviewed_by}\n\n",
      "Review outcome: {review_outcome}\n\n",
      "Comments: {comments}"
    )
  ) %>%
  dplyr::filter(category != 0) %>%
  dplyr::filter(taxon != 0)

# IUCN(2001) 4
tfa_listing_cat_iucn2001 <- tfa_tcl %>%
  dplyr::filter(list_code == "IUCN(2001)") %>%
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 4),
    by = "category_code"
  ) %>%
  dplyr::transmute(
    source = 1, # TaxonGaz.source TFA
    source_id = source_id %>% as.character(),
    scope = 0,
    status = ifelse(is.na(delisted_on), 80, 90),
    effective_from = gazetted_on,
    effective_to = delisted_on,
    last_reviewed_on = last_reviewed_on,
    taxon = name_id %>% as.numeric(),
    category = tsc_category_id,
    criteria = tsc_criteria,
    comments = glue::glue(
      "Reviewed by {reviewed_by}\n\n",
      "Review outcome: {review_outcome}\n\n",
      "Comments: {comments}"
    )
  ) %>%
  dplyr::filter(category != 0) %>%
  dplyr::filter(taxon != 0)

# IUCN(1994) 5
tfa_listing_cat_iucn1994 <- tfa_tcl %>%
  dplyr::filter(list_code == "IUCN(1994)") %>%
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 5),
    by = "category_code"
  ) %>%
  dplyr::transmute(
    source = 1, # TaxonGaz.source TFA
    source_id = source_id %>% as.character(),
    scope = 0,
    status = ifelse(is.na(delisted_on), 80, 90),
    effective_from = gazetted_on,
    effective_to = delisted_on,
    last_reviewed_on = last_reviewed_on,
    taxon = name_id %>% as.numeric(),
    category = tsc_category_id,
    criteria = tsc_criteria,
    comments = glue::glue(
      "Reviewed by {reviewed_by}\n\n",
      "Review outcome: {review_outcome}\n\n",
      "Comments: {comments}"
    )
  ) %>%
  dplyr::filter(category != 0) %>%
  dplyr::filter(taxon != 0)

# WAWCA 1
tfa_listing_cat_wawca <- tfa_tcl %>%
  dplyr::filter(list_code == "WAWCA") %>%
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 1),
    by = "category_code"
  ) %>%
  dplyr::transmute(
    source = 1, # TaxonGaz.source TFA
    source_id = source_id %>% as.character(),
    scope = 0,
    status = ifelse(is.na(delisted_on), 80, 90),
    effective_from = gazetted_on,
    effective_to = delisted_on,
    last_reviewed_on = last_reviewed_on,
    taxon = name_id %>% as.numeric(),
    category = tsc_category_id,
    criteria = tsc_criteria,
    comments = glue::glue(
      "Reviewed by {reviewed_by}\n\n",
      "Review outcome: {review_outcome}\n\n",
      "Comments: {comments}"
    )
  ) %>%
  dplyr::filter(category != 0) %>%
  dplyr::filter(taxon != 0)

# SPFN 2
tfa_listing_cat_spfn <- tfa_tcl %>%
  dplyr::filter(list_code == "SPFN") %>%
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 2),
    by = "category_code"
  ) %>%
  dplyr::transmute(
    source = 1, # TaxonGaz.source TFA
    source_id = source_id %>% as.character(),
    scope = 0,
    status = ifelse(is.na(delisted_on), 80, 90),
    effective_from = gazetted_on,
    effective_to = delisted_on,
    last_reviewed_on = last_reviewed_on,
    taxon = name_id %>% as.numeric(),
    category = tsc_category_id,
    criteria = tsc_criteria,
    comments = glue::glue(
      "Reviewed by {reviewed_by}\n\n",
      "Review outcome: {review_outcome}\n\n",
      "Comments: {comments}"
    )
  ) %>%
  dplyr::filter(category != 0) %>%
  dplyr::filter(taxon != 0)

# WAPS 6
tfa_listing_cat_waps <- tfa_tcl %>%
  dplyr::filter(list_code == "WAPF") %>%
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 6),
    by = "category_code"
  ) %>%
  dplyr::transmute(
    source = 1, # TaxonGaz.source TFA
    source_id = source_id %>% as.character(),
    scope = 0,
    status = ifelse(is.na(delisted_on), 80, 90),
    effective_from = gazetted_on,
    effective_to = delisted_on,
    last_reviewed_on = last_reviewed_on,
    taxon = name_id %>% as.numeric(),
    category = tsc_category_id,
    criteria = tsc_criteria,
    comments = glue::glue(
      "Reviewed by {reviewed_by}\n\n",
      "Review outcome: {review_outcome}\n\n",
      "Comments: {comments}"
    )
  ) %>%
  dplyr::filter(category != 0) %>%
  dplyr::filter(taxon != 0)

# EPBC 7
tfa_listing_cat_epbc <- tfa_tcl %>%
  dplyr::filter(list_code == "EPBC") %>%
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 7),
    by = "category_code"
  ) %>%
  dplyr::transmute(
    source = 1, # TaxonGaz.source TFA
    source_id = source_id %>% as.character(),
    scope = 1,
    status = ifelse(is.na(delisted_on), 80, 90),
    effective_from = gazetted_on,
    effective_to = delisted_on,
    last_reviewed_on = last_reviewed_on,
    taxon = name_id %>% as.numeric(),
    category = tsc_category_id,
    criteria = tsc_criteria,
    comments = glue::glue(
      "Reviewed by {reviewed_by}\n\n",
      "Review outcome: {review_outcome}\n\n",
      "Comments: {comments}"
    )
  ) %>%
  dplyr::filter(category != 0) %>%
  dplyr::filter(taxon != 0)
```


```{r load_tfa_tcl, eval=FALSE}
# Example: one record
# tfa_listing_cat_iucn2012_res <- tfa_listing_cat_iucn2012[1,] %>%
#   wastdr::wastd_POST("taxon-conservationlisting")
# tfa_listing_cat_iucn2001_res <- tfa_listing_cat_iucn2001[1,] %>%
#   wastdr::wastd_POST("taxon-conservationlisting")
# tfa_listing_cat_iucn1994_res <- tfa_listing_cat_iucn1994[1,] %>%
#   wastdr::wastd_POST("taxon-conservationlisting")
# tfa_listing_cat_wawca_res <- tfa_listing_cat_wawca[1,] %>%
#   wastdr::wastd_POST("taxon-conservationlisting")
# tfa_listing_cat_spfn_res <- tfa_listing_cat_spfn[1,] %>%
#   wastdr::wastd_POST("taxon-conservationlisting")
# tfa_listing_cat_waps_res <- tfa_listing_cat_waps[1,] %>%
#   wastdr::wastd_POST("taxon-conservationlisting")
# tfa_listing_cat_epbc_res <- tfa_listing_cat_epbc[1,] %>%
#   wastdr::wastd_POST("taxon-conservationlisting")

# LONG RUNNING UPLOAD
tfa_listing_cat_iucn2012_res <- tfa_listing_cat_iucn2012 %>% 
  wastdr::wastd_POST("taxon-conservationlisting")
tfa_listing_cat_iucn2001_res <- tfa_listing_cat_iucn2001 %>% 
  wastdr::wastd_POST("taxon-conservationlisting")
tfa_listing_cat_iucn1994_res <- tfa_listing_cat_iucn1994 %>% 
  wastdr::wastd_POST("taxon-conservationlisting")

# DO NOT LOAD THESE DUPLICATES:
# tfa_listing_cat_wawca_res <- tfa_listing_cat_wawca %>% 
#   wastdr::wastd_POST("taxon-conservationlisting")
# tfa_listing_cat_spfn_res <- tfa_listing_cat_spfn %>% 
#   wastdr::wastd_POST("taxon-conservationlisting")

tfa_listing_cat_waps_res <- tfa_listing_cat_waps %>% 
  wastdr::wastd_POST("taxon-conservationlisting")
tfa_listing_cat_epbc_res <- tfa_listing_cat_epbc %>% 
  wastdr::wastd_POST("taxon-conservationlisting")

# Expire cached TSC TCL
if (file.exists(tsc_cl_fauna_datafile)) {fs::file_delete(tsc_cl_fauna_datafile)}
```

## Occurrences

The EOO (Extent of occurrence) is calculated as the convex hull around all 
recorded fauna occurrences, including fossil records.
For further details on the methodology behind the movement of EOO data, 
please follow the link to the workbook.

### Upload EOOs to TSC

```{r make_eoo, eval=FALSE}
# extract all eoo
tfa_occ_with_coords <- tfa_occ %>% 
  dplyr::filter(!is.na(latitude)) %>% 
  dplyr::filter(!is.na(longitude)) %>% 
  dplyr::filter(longitude > 96)

# The total convex hull of all occurrences (one polygon)
tfa_eoo_all <- eoo_polygon(tfa_occ_with_coords)
mapview::mapview(tfa_eoo_all)

# Calculate EOO for each taxon
tfa_eoo <- tfa_occ_with_coords %>% make_eoo()
# mapview::mapview(head(tfl_eoo$eoo_sfc))
```

```{r load_eoo, eval=F}
tfa_eoo %>% dplyr::select(-data, -eoo_sfc) %>% wastdr::wastd_POST("taxon")
```

### Upload TAEs to TSC

A single record (taxon area encounter), or a list of (one or) many records, 
can be uploaded to the TSC API as follows.

```{r load_tfa_tae, eval=FALSE}
# Test upload one, some, many to local or PROD:
# 25757
taxonpoint = rjson::fromJSON(
  '[{"taxon": 25757, 
  "code": "Condingup", 
  "description": "Pine plantations off Fisheries Rd east of Condinup\n
  Opportunistic sighting\nDay sighting\nHeard/Call\n
  Saw a flock of approximately 200 birds in the pine plantation\n
  Observed by Abby Thomas, DBCA Technical Officer, Albany",   
  "source": 10,
  "source_id": "94654",    
  "encountered_on": "2018-04-16T15:00:00+08:00",    
  "encountered_by": 1, 
  "encounter_type":1,  
  "area_type": 30,    
  "accuracy": 1000.0,    
  "point":"SRID=4326;POINT(119.732234 -32.35756)"}]'
)
wastdr::wastd_POST(taxonpoint, serializer = "occ-taxon-points")

x <- tfa_tae[1,] %>% as.list() %>%
  # Or use any of:
  # tfa_tae[1:100,] %>%
  # tfa_tae[1:1000,] %>%
  wastd_POST(serializer = "occ-taxon-points")

# Upload all occurrences to TSC PROD
# LONG RUNNING UPLOAD
tfa_tae_res <- tfa_tae %>% chunk_post(serializer = "occ-taxon-points", chunksize = 1000)

# tfa_tae[100001:nrow(tfa_tae),] %>% chunk_post(serializer = "occ-taxon-points", chunksize = 100)
    # , api_url = dev, api_token = Sys.getenv("WASTDR_API_DEV_TOKEN"))
```

### Upload ObservationGroups

* Associated species are free text which will never map to proper taxonomic names.
  TODO add as plain text to TAE comments. 
  Challenge: merge 0 to many associated species per TAE into one comment.

```{r load_obsgroups, eval=FALSE}
# Examples:
# tfa_phys_sample_res <- tfa_phys_sample[1,] %>%
#   wastd_occ_obs_post(obstype="PhysicalSample")
# tfa_phys_sample_res <- tfa_phys_sample[1:100,] %>%
#   wastd_occ_obs_post(obstype="PhysicalSample")

# Bulk upload
# LONG RUNNING UPLOAD - RE-RUNS CREATE DUPLICATES
tfa_phys_sample_res <- tfa_phys_sample %>% 
  wastd_occ_obs_post(obstype="PhysicalSample") 

tfa_anim_obs_res <- tfa_anim_obs %>% 
  wastd_occ_obs_post(obstype="AnimalObservation")

# We cannot map hand-written AssSpecies to TSC NameIDs.
# tfa_ass_species_res <- tfa_ass_species[1,] %>% 
#   wastd_occ_obs_post(obstype="AssociatedSpecies")

tfa_veg_class_res <- tfa_veg_class %>% 
  wastd_occ_obs_post(obstype="VegetationClassification")

tfa_hab_comp_res <- tfa_hab_comp %>% 
  wastd_occ_obs_post(obstype="HabitatComposition")

# Export as (confidential) test data for API
tfa_phys_sample %>% readr::write_csv(path = here::here("data/tfa_phys_sample.csv"))
tfa_anim_obs %>% readr::write_csv(path = here::here("data/tfa_anim_obs.csv"))
tfa_ass_species %>% readr::write_csv(path = here::here("data/tfa_ass_species.csv"))
tfa_veg_class %>% readr::write_csv(path = here::here("data/tfa_veg_class.csv"))
tfa_hab_comp %>% readr::write_csv(path = here::here("data/tfa_hab_comp.csv"))
```

## Conservation Documents

## Fire History

## Conservation Threats and Actions

# Migrated Data (TSC)

# Migrated Data (TSC)

Data from TSC is extracted through the TSC API and transformed into a usable
format. This process is also the template for future reporting from TSC.

First, we get a list of taxonomic names from TSC to resolve taxon IDs from
taxon occurrences to names.

Next, we extract conservation listings.

Last, we get taxon occurrences with their point representations from TSC through 
the API endpoint 
[occ-taxon-points](https://tsc.dbca.wa.gov.au/api/1/occ-taxon-points/).

Currently, all Fauna occurrences are geo-referenced only with point
coordinates, not polygons.

We also get TSC Areas and split them into DBCA Regions and Districts. Caveat:
Regions and Districts to not comprehensively cover WA, and they are multi-polygons.
We do not join these multi-polygons to the data to prevent duplicates.

Expand the code block below to view the process.

```{r get_tsc_occ}
if (file.exists(tsc_extracted_fauna)) {
  load(tsc_extracted_fauna)
} else {
# WACensus is the upstream source of taxonomic names
wace_names <- "public:herbie_hbvnames_public" %>%
  gs_getFeature() %>%
  magrittr::extract2("features") %>%
  {
    tibble::tibble(
      name_id = purrr::map(., c("properties", "name_id")) %>% flatten_chr(),
      wace_name = purrr::map(., c("properties", "name")) %>% flatten_chr()
    )
  }

# Taxonomic names and taxon conservation listings for fauna from TSC
  tsc_taxa_fauna <- "taxon" %>%
    wastdr::wastd_GET(api_url = prod,
                      query = list(paraphyletic_groups = 20)) %>%
    wastdr::wastd_parse() %>%
    dplyr::mutate(name_id = name_id %>% as.character())%>%
    dplyr::mutate(taxon = name_id %>% as.character())
  
  # Taxon conservation listings for fauna
  tsc_tcl_fauna <-
    wastdr::wastd_GET("taxon-conservationlisting") %>%
    wastdr::wastd_parse()  %>%
    dplyr::mutate(name_id = taxon %>% as.character()) %>%
    dplyr::inner_join(tsc_taxa_fauna, by = "name_id")
  
  tsc_tae_data <- wastdr::wastd_GET("occ-taxon-points") # 137k records
 
  tsc_tae <- tsc_tae_data %>%
    magrittr::extract2("data") %>%
    geojsonio::as.json() %>%
    geojsonsf::geojson_sf() %>%
    dplyr::mutate(taxon = taxon %>% as.character())
 
  tsc_tae_sf <- tsc_tae_data %>%
    magrittr::extract2("data") %>%
    geojsonio::as.json() %>%
    geojsonsf::geojson_sf() %>%
    dplyr::mutate(taxon = taxon %>% as.character())
  
  tsc_taxa_fauna <- "taxon" %>%
    wastdr::wastd_GET(api_url = prod,
                      query = list(paraphyletic_groups = 20)) %>%
    wastdr::wastd_parse() %>%
    dplyr::mutate(taxon = name_id %>% as.character())
  
  tsc_areas <- wastdr::wastd_GET("area") %>%
    magrittr::extract2("data") %>%
    geojsonio::as.json() %>%
    geojsonsf::geojson_sf()
  
  regions <- tsc_areas %>%
    dplyr::filter(area_type == "Region") %>%
    dplyr::transmute(region_id = pk, region_name = name)
  
  districts <- tsc_areas %>%
    dplyr::filter(area_type == "District") %>%
    dplyr::transmute(district_id = pk, district_name = name)
  
  tsc_occ_fauna <- tsc_tae %>% 
    dplyr::filter(source == 10) %>% 
     # sf::st_join(regions) %>% 
    # sf::st_join(districts) %>%
    dplyr::mutate(taxon = taxon %>% as.character()) %>% 
    dplyr::left_join(tsc_taxa_fauna, by = c("taxon"))
  
   # Flora occurrence observations
  tsc_tae_observations_fauna <- "occ-observation" %>% 
    wastdr::wastd_GET(query = list(source=10)) %>%
    wastdr::wastd_parse()
  
  save(
    wace_names,
    tsc_taxa_fauna, 
    tsc_tcl_fauna,
    tsc_tae,
    tsc_taxa_fauna,
    tsc_areas,
    regions,
    districts,
    tsc_occ_fauna, 
    tsc_tae_observations_fauna,
    file = tsc_extracted_fauna)
}
```


```{r show_duplicates_and_missing_tae, eval = FALSE}
# All sources are fauna (10)
tsc_occ_fauna_no <- tsc_tae %>%
  dplyr::filter(source == 10)

unique(tsc_occ_fauna$source)
length(unique(tsc_occ_fauna$source_id)) # 102248

## Check for duplicates
tsc_tae_fauna_dup <- tsc_tae %>%
  dplyr::filter(source == 10) %>% 
  dplyr::filter(source_id %in% unique(.[["source_id"]][duplicated(.[["source_id"]])]))

tsc_occ_fauna_dup <- tsc_occ_fauna %>%
  filter(source_id %in% unique(.[["source_id"]][duplicated(.[["source_id"]])]))

#### Identify missing tae in tsc\_tae
tfa_tae_create <- tfa_tae %>% 
  dplyr::anti_join(tsc_occ_fauna, by = "source_id")

tfa_tae_update <- tfa_tae %>% 
  dplyr::semi_join(tsc_occ_fauna, by = "source_id")

## Upload the missing tfa_tae to tsc_tae
tfa_tae_create_res <- tfa_tae_create %>% chunk_post(serializer = "occ-taxon-points", chunksize = 100)
```

# Compare legacy from TFA to migrated data from TSC

This section provides an automated comparison between original data from TFA 
and TFA data as uploaded into TSC. 

Data custodians should be able to comprehend this section, and be able to verify 
that the data migration has worked correctly.

Legacy data snapshot used for TFA was updated last on `r snapshot_last_updated`.

## Summary statistics

Check unique number of species by name\_id. Check unique number of observations
and identify observations missing from TSC compared to TFA.

```{r make_tfl_summary}
tfa_tcl_edit <- tfa_tcl %>%
  dplyr::filter(list_code != "ActionPlan") %>%
  dplyr::filter(list_code != "BCA") %>%
  dplyr::filter(list_code != "RedList") %>%
  dplyr::mutate(source_id = source_id %>% as.character())

tfa_tcl_unique_taxa <- tfa_tcl_edit$name_id %>%
  unique() %>%
  length()

tsc_tcl_unique_taxa <- tsc_tcl_fauna$name_id %>%
  unique() %>%
  length()
```

## Taxonomy

This section QAs taxonomy.

* TFA contains manually updated names from WACensus, plus new phrase names.
* TSC contains a synchronised copy of WACensus names.
* TSC contains all WACensus names. 
* TFA contains most but not all WACensus animal names.
* TFA is mapped to TSC via NameID.
* This section analyses whether the names match the NameID between TFA and
  WACensus.

### Name mismatches
For a given NameID, the scientific name in TFA should be identical to 
the scientific name in WACensus with the same NameID. 
A name mismatch is an indication for review.

```{r show_tfa_wacensus_name_mismatch}
tfa_data_wacensus <- species_names %>%
  dplyr::left_join(wace_names, by = "name_id")

name_mismatches <- tfa_data_wacensus %>%
  dplyr::filter(scientific_name != wace_name) %>%
  dplyr::select(name_id, species_code, scientific_name, wace_name)
```

#### Mismatches containing "subsp"
WACensus names contain "subsp." whereas TFA don't. 
Therefore, scientific name mismatches by only the "subsp" can be ignored.

**QA** Review this list to make sure both WACensus and TFA mean the same name.
If the TFA "scientific_name" means a different taxon than the "wace_name", TFA's
NameID must be changed to the WACensus NameID of the correct taxon.

```{r show_name_mismatches_subsp}
name_mismatches %>%
  dplyr::filter(grepl("subsp", wace_name)) %>% rt
```

#### Typo mismatches
The remaining mismatches contain minor differences, such as "sp." vs "sp", 
parentheses and quotation marks.

```{r show_name_mismatches_typo}
name_mismatches %>%
  dplyr::filter(!grepl("subsp", wace_name)) %>% rt
```

#### True mismatches
The remaining mismatches require a review of the scientific name or NameID in TFA.

**QA** If the TFA "scientific_name" is meant to refer to a different taxon than 
the "wace_name", TFA's NameID must be changed to the WACensus NameID of the 
correct taxon.

```{r show_name_mismatches_real}
drop_cruft <- . %>%
  stringr::str_remove_all("[.()'\"]|sp|subsp") %>%
  stringr::str_replace_all("  ", " ")

true_mismatches <- tfa_data_wacensus %>%
  dplyr::mutate(
    scientific_name = scientific_name %>% drop_cruft(),
    wace_name = wace_name %>% drop_cruft()
  ) %>%
  dplyr::filter(scientific_name != wace_name) %>%
  dplyr::select(name_id, species_code, scientific_name, wace_name)

true_mismatches %>% rt
```

### Species notes duplications
The records below are duplicated `species_code` in `Species Notes`, which is extracted from `tfa_data`.
They need to be correct so there is only one record for each `species_code`.

```{r show_species_note_duplicates}
tfa_species_notes_duplications <- species_notes_with_duplicates %>%
  filter(species_code %in% unique(.[["species_code"]][duplicated(.[["species_code"]])])) %>% as_tibble()

tfa_species_notes_duplications %>% rt
```

### Species list duplications
The records below are duplicated `name_id` in `Species List`, which is extracted from `tfa_data`.
They need to be correct so there is only one record for each `name_id`. `name_id` must be unique for each species, including sub-species otherwise they cannot be migrated to TSC.

````{r show_species_list_duplicates}
tfa_species_list_duplications <- species_with_duplicates %>%
  filter(name_id %in% unique(.[["name_id"]][duplicated(.[["name_id"]])])) %>% as_tibble()

tfa_species_list_duplications %>% rt
```

### Species names in TFA but not in TSC
Since TSC contains all WACensus names, all names in TFA with a NameID other 
than 0 (indicating a phrase name) should also occur in TSC.

Any records in the following table require review.

```{r show_species_names_in_tfa_not_in_tsc}
species_names %>%
  anti_join(tsc_taxa_fauna, by = c("name_id" = "taxon")) %>%
  reactable::reactable(filterable = TRUE)
```

### Names in TSC but not in TFA
There are more names in TSC that are not in TFA, as TSC maintains a full copy
of WACensus, whereas TFA only contains names it actually needs.

Records in the following table require no action, but are shown here for 
completeness.

```{r show_species_names_in_tsc_not_in_tfa}
tsc_taxa_fauna %>%
  anti_join(species_names, by = c("taxon" = "name_id")) %>%
  reactable::reactable(filterable = TRUE)
```

## Conservation Listing

TFA has `r nrow(tfa_tcl_edit)` conservation listings of `r tfa_tcl_unique_taxa` unique taxa.
TSC has `r nrow(tsc_tcl_fauna)` fauna conservation listings of 
`r tsc_tcl_unique_taxa`, including animals but excluding plants.

### `tfa_tcl` conservation listings not in `tsc_tcl_fauna`

Any records in the following table indicate conservation listings in TFA that
were not migrated into TSC. 

Already excluded are conservation listings from the excluded categories 
"ActionPlan", "RedList", and "BCA".

```{r show_tfa_tcl_not_in_tsc}
tfa_tcl_edit %>%
  dplyr::anti_join(tsc_tcl_fauna, by = "source_id") %>%
  reactable::reactable(filterable = TRUE)
```

### `tsc_tcl_fauna` conservation listings not in `tfa_tcl`

The following table shows any conservation listings in TSC which are not in TFA.
Because there are more taxa in TSC than TFA, taxa with no source\_id have also
been removed.

```{r show_tsc_tcl_not_in_tfl}
tsc_tcl_fauna %>%
  dplyr::anti_join(tfa_tcl_edit, by = "source_id") %>%
  reactable::reactable(filterable = TRUE)
```

### `tfa_tcl` listed phrase names

Some TFA cons listings have a name\_id of 0. These are phrase names and require
to be assigned the name\_id of the published name, once the published name is
known and entered into WACensus, then propagated into TSC.

```{r show_tfa_tcl_without_nameid}
tfa_tcl_edit %>% dplyr::filter(name_id == 0) %>% rt
```

### TFA unmigrated conservation listings

ActionPlan (a book), the IUCN RedList (accessible online and via API), and BCA
listings (erroneous) are excluded from the data migration.

They are listed here.

```{r show_unmigrated_cl}
tfa_tcl %>%
  dplyr::filter(list_code == c("ActionPlan", "BCA", "RedList")) %>% rt
```

### Conservation criteria mapping

Conservation criteria were manually mapped for each species, 
therefore they need to be checked to confirm whether the mapping is correct. 

```{r show_cl_mapping}
tfa_conscrit %>% rt
```

Some conservation criteria could not be mapped as they do not exist in the
`list_code` / `category_code`.

These need to be corrected before the manual mapping can be updated and the 
correct criteria assigned for all species.

### Conservation listing dates

Below are the dates of the most recent conservation criteria changes made in the
snapshot of the TFA.

Excluded are TFA cons listings of unmigrated lists (AP, RL, BCA).

``` {r qa_effective_dates}
tsc_corner_dates <- tsc_tcl_fauna %>%
  summarise(
    effective_from_min = min(effective_from, na.rm = T),
    effective_from_max = max(effective_from, na.rm = T),
    effective_to_min = min(effective_to, na.rm = T),
    effective_to_max = max(effective_to, na.rm = T),
    last_reviewed_on_min = min(last_reviewed_on, na.rm = T),
    last_reviewed_on_max = max(last_reviewed_on, na.rm = T)
  )

tfa_corner_dates <- tfa_tcl_edit %>%
  summarise(
    effective_from_min = min(gazetted_on, na.rm = T),
    effective_from_max = max(gazetted_on, na.rm = T),
    effective_to_min = min(delisted_on, na.rm = T),
    effective_to_max = max(delisted_on, na.rm = T),
    last_reviewed_on_min = min(last_reviewed_on, na.rm = T),
    last_reviewed_on_max = max(last_reviewed_on, na.rm = T)
  )

cl_corner_dates <- rbind(tfa_corner_dates, tsc_corner_dates) %>%
  t() %>%
  magrittr::set_colnames(c("TFA", "TSC"))

cl_corner_dates %>% reactable::reactable()
```

### Conservation listing differences

Summary of the number of conservation listings for each list.

Discrepancies in numbers indicate the need for a closer review.

Equality of numbers does not prove absence of equal numbers of false positives
and false negatives.

```{r make_conslist_summary}
make_tfa_cl_summary <-
  . %>% nrow() %>% as.data.frame() %>% magrittr::set_colnames("TFA")

tfa_cl_sum_iucn1994 <- 
  tfa_listing_cat_iucn1994 %>% make_tfa_cl_summary
tfa_cl_sum_iucn2001 <- 
  tfa_listing_cat_iucn2001 %>% make_tfa_cl_summary
tfa_cl_sum_iucn2012 <- 
  tfa_listing_cat_iucn2012 %>% make_tfa_cl_summary
tfa_cl_sum_wawca <- 
  tfa_listing_cat_wawca %>% make_tfa_cl_summary
tfa_cl_sum_waps <- 
  tfa_listing_cat_waps %>% make_tfa_cl_summary
tfa_cl_sum_spfn <- 
  tfa_listing_cat_spfn %>% make_tfa_cl_summary
tfa_cl_sum_epbc <- 
  tfa_listing_cat_epbc %>% make_tfa_cl_summary

make_tsc_cl_summary <- function(data, cn){
  data %>%
  dplyr::select(category_cache) %>%
  dplyr::filter(str_detect(category_cache, cn)) %>%
  nrow() %>% 
  as.data.frame %>% 
  magrittr::set_colnames("TSC")
}

tsc_cl_sum_iucn1994 <- 
  tsc_tcl_fauna %>% make_tsc_cl_summary("IUCN1994")
tsc_cl_sum_iucn2001 <- 
  tsc_tcl_fauna %>% make_tsc_cl_summary("IUCN2001")
tsc_cl_sum_iucn2012 <- 
  tsc_tcl_fauna %>% make_tsc_cl_summary("IUCN2012")
tsc_cl_sum_wawca <- 
  tsc_tcl_fauna %>% make_tsc_cl_summary("WAWCA")
tsc_cl_sum_waps <- 
  tsc_tcl_fauna %>% make_tsc_cl_summary("WAPS")
tsc_cl_sum_spfn <- 
  tsc_tcl_fauna %>% make_tsc_cl_summary("SPFN")
tsc_cl_sum_epbc <- 
  tsc_tcl_fauna %>% make_tsc_cl_summary("EPBC")


tfa_cons_cat_sum <- rbind(
  tfa_cl_sum_iucn1994, 
  tfa_cl_sum_iucn2001, 
  tfa_cl_sum_iucn2012, 
  tfa_cl_sum_wawca, 
  tfa_cl_sum_waps,
  tfa_cl_sum_spfn, 
  tfa_cl_sum_epbc
)

tsc_cons_cat_sum <- rbind(
  tsc_cl_sum_iucn1994, 
  tsc_cl_sum_iucn2001, 
  tsc_cl_sum_iucn2012, 
  tsc_cl_sum_wawca, 
  tsc_cl_sum_waps,
  tsc_cl_sum_spfn, 
  tsc_cl_sum_epbc 
  )

cons_cat_summary <- tfa_cons_cat_sum %>%
  cbind(tsc_cons_cat_sum) %>%
  cbind(Category = c("IUCN1994", "IUCN2001", "IUCN2012", 
                     "WAWCA", "WAPS", "SPFN", "EPBC")) %>%
  dplyr::select("Category", everything())

cons_cat_summary %>% rt
```

The following tables show any conservation listings in TFA which are not in TSC, for each conservation list.

IUCN 2012

```{r show_tfa_tcl_not_in_tsc_iucn2012}
#### IUCN 2012
tsc_listing_cat_iucn2012 <- tsc_tcl_fauna %>%
  dplyr::mutate(taxon = name_id %>% as.integer) %>% 
  dplyr::filter(str_detect(category_cache, "IUCN(2012)"))

tfa_listing_cat_iucn2012 %>% 
  dplyr::anti_join(tsc_listing_cat_iucn2012, by = "taxon") %>%
  rt
```

IUCN 2001

```{r show_tfa_tcl_not_in_tsc_iucn2001}
#### IUCN 2001
tsc_listing_cat_iucn2001 <- tsc_tcl_fauna %>%
  dplyr::mutate(taxon = name_id %>% as.integer) %>% 
  dplyr::filter(str_detect(category_cache, "IUCN(2001)"))

tfa_listing_cat_iucn2001 %>% 
  dplyr::anti_join(tsc_listing_cat_iucn2001, by = "taxon") %>%
  rt
```

IUCN 1994

```{r show_tfa_tcl_not_in_tsc_iucn1994}
#### IUCN 1994
tsc_listing_cat_iucn1994 <- tsc_tcl_fauna %>%
  dplyr::mutate(taxon = name_id %>% as.integer) %>% 
  dplyr::filter(str_detect(category_cache, "IUCN(1994)"))

tfa_listing_cat_iucn1994 %>% 
  dplyr::anti_join(tsc_listing_cat_iucn1994, by = "taxon") %>%
  rt
```

WAWCA

```{r show_tfa_tcl_not_in_tsc_wawca}
#### WAWCA
tsc_listing_cat_wawca <- tsc_tcl_fauna %>%
  dplyr::mutate(taxon = name_id %>% as.integer) %>% 
  dplyr::filter(str_detect(category_cache, "WAWCA"))

tfa_listing_cat_wawca %>% 
  dplyr::anti_join(tsc_listing_cat_wawca, by = "taxon") %>%
  rt
```

WAPS

```{r show_tfa_tcl_not_in_tsc_waps}
#### WAPS
tsc_listing_cat_waps <- tsc_tcl_fauna %>%
  dplyr::mutate(taxon = name_id %>% as.integer) %>% 
  dplyr::filter(str_detect(category_cache, "WAPS"))

tfa_listing_cat_waps %>% 
  dplyr::anti_join(tsc_listing_cat_waps, by = "taxon") %>%
  rt
```

SPFN

```{r show_tfa_tcl_not_in_tsc_spfn}
#### SPFN
tsc_listing_cat_spfn <- tsc_tcl_fauna %>%
  dplyr::mutate(taxon = name_id %>% as.integer) %>% 
  dplyr::filter(str_detect(category_cache, "SPFN"))

tfa_listing_cat_spfn %>% 
  dplyr::anti_join(tsc_listing_cat_spfn, by = "taxon") %>%
  rt
```

EPBC

```{r show_tfa_tcl_not_in_tsc_epbc}
#### EPBC
tsc_listing_cat_epbc <- tsc_tcl_fauna %>%
  dplyr::mutate(taxon = name_id %>% as.integer) %>% 
  dplyr::filter(str_detect(category_cache, "EPBC"))

tfa_listing_cat_epbc %>% 
  dplyr::anti_join(tsc_listing_cat_epbc, by = "taxon") %>%
  rt
```

The following tables show any conservation listings in TSC which are not in TFA, 
for each conservation list.

IUCN 2012

```{r show_tsc_tcl_not_in_tfa_iucn2012}
#### IUCN 2012
tsc_listing_cat_iucn2012 %>%
  dplyr::anti_join(tfa_listing_cat_iucn2012, by = "taxon") %>%
  rt
```

IUCN 2001

```{r show_tsc_tcl_not_in_tfa_iucn2001}
#### IUCN 2001
tsc_listing_cat_iucn2001 %>% 
  dplyr::anti_join(tfa_listing_cat_iucn2001,by = "taxon") %>% 
  rt
```

IUCN 1994

```{r show_tsc_tcl_not_in_tfa_iucn1994}
#### IUCN 1994
tsc_listing_cat_iucn1994 %>% 
  dplyr::anti_join(tfa_listing_cat_iucn1994,by = "taxon") %>% 
  rt
```

WAWCA

```{r show_tsc_tcl_not_in_tfa_wawca}
#### WAWCA
tsc_listing_cat_wawca %>% 
  dplyr::anti_join(tfa_listing_cat_wawca,by = "taxon") %>% 
  rt
```

WAPS

```{r show_tsc_tcl_not_in_tfa_waps}
#### WAPS
tsc_listing_cat_waps %>% 
  dplyr::anti_join(tfa_listing_cat_waps,by = "taxon") %>% 
  rt
```

SPFN

```{r show_tsc_tcl_not_in_tfa_spfn}
#### SPFN
tsc_listing_cat_spfn %>% 
  dplyr::anti_join(tfa_listing_cat_spfn,by = "taxon") %>% 
  rt
```

EPBC

```{r show_tsc_tcl_not_in_tfa_epbc}
#### EPBC
tsc_listing_cat_epbc %>% 
  dplyr::anti_join(tfa_listing_cat_epbc,by = "taxon") %>% 
  rt
```

## Occurrences

#### Date/ Location caveats

This section lists data issues which need to be fixed at the source (here, in 
legacy TFA).

Where a time is missing, we'll default to midnight (00:00). Where a date is
missing, we'll default to 1900-01-01.

While this modifies the original data, the consequences will not have a dramatic
effect on analyses for conservation management purposes:

-   A safe default of the observation time (midnight) could introduce an error
    of up to one day. Compared to the time frame considered (past 10-50 years of
    observations relative to time of calculation), this error is minuscule.
-   A safe default for missing dates (1900-01-01) will both exclude those
    observations from any recent observations (past 10-50 years), but still make
    the data available to identify the records for the purpose of backfilling a
    credible date.

Please review legacy data until the following numbers are all zero (or accept
default handling):

-   `r tfa_occ %>% dplyr::filter(is.na(datetime)) %>% nrow()` records lack an
    explicit date\time and were defaulted to midnight AWST.
-   `r tfa_occ %>% dplyr::filter(orig_time == "") %>% nrow()` records lack an 
    explicit time and were defaulted to midnight AWST.
-   `r tfa_occ %>% dplyr::filter(orig_date == "") %>% nrow()` records lack an 
    explicit date and were defaulted to 1900-01-01.
-   `r tfa_occ %>% dplyr::filter(is.na(latitude)) %>% nrow` latitudes are 
    missing.
-   `r tfa_occ %>% dplyr::filter(is.na(longitude)) %>% nrow` longitudes are 
    missing.
-   `r tfa_occ %>% dplyr::filter(latitude > 0) %>% nrow` latitudes lack the 
    minus sign and turn up in China.

There are `r nrow(tfa_occ)` species occurrence records (encounters)in TFA. 
The following columns are incomplete.

```{r show_tfa_occ_missing_values}
tfa_skim <- tfa_occ %>% skimr::skim()

tfa_skim %>%
  filter(n_missing > 0) %>%
  # select(-stat, -level, -formatted) %>%
  rt

# Big Fauna: taxa with a lot of sightings
tfa_tae_big <- tfa_tae %>% dplyr::group_by(taxon) %>% dplyr::tally() %>% dplyr::arrange(-n) %>% filter(n>400) %>% ungroup()
```

#### Missing date/times- orig_date

```{r missing orig_dates}
tfa_occ_no_date <- tfa_occ %>% 
    filter(orig_date == "")
tfa_occ_no_date %>% rt
```
There are `r nrow(tfa_occ_no_date)` distinct scientific fauna names missing an orig_date.

#### Missing date/times- orig_time

```{r missing_orig_times}
tfa_occ_no_time<- tfa_occ %>% 
    filter(orig_time == "")
tfa_occ_no_time %>% rt
```
There are `r nrow(tfa_occ_no_time)` distinct scientific fauna names missing an orig_time.

#### Default date/times
Orig_date was used to populate the datetime field in tfa_occ and encountered_on in 
tfa_tae. Records with no date/time for the encountered_on field were given a 
default datetime. The records below are those.

```{r default_encountered_on}
tfa_tae_default_datetime <- tfa_tae %>% 
  filter(encountered_on == "1900-01-01 00:00:00+08:00") %>% rt
```

#### Missing coordinates

```{r missing_coordinates}
tfa_occ_no_latlng <- tfa_occ %>% 
    filter(is.na(latitude) | is.na(longitude))
tfa_occ_no_latlng %>% rt
```

There are `r nrow(tfa_occ_no_latlng)` distinct fauna records with missing latitude or longitude.

```{r has_eastnorthings}
tfa_occ_no_latlng_w_ne <- tfa_occ %>% 
  filter(is.na(latitude) | is.na(longitude)) %>% 
  filter((northing != "NA") | (easting!= "NA"))
tfa_occ_no_latlng_w_ne %>% rt
```

There are `r nrow(tfa_occ_no_latlng_w_ne)` distinct fauna records with missing latitude or longitude, which have northings and eastings.

#### Impossible locations
Geographic coordinates outside possible boundaries must be rectified at source.
```{r tfa_occ_impossible_locations}
tfa_occ %>% impossible_location() %>% rt
```

#### Out of bounds locations
Geographic coordinates outside sensible boundaries must be rectified at source.
```{r tfa_occ_unlikely_locations}
tfa_occ %>% filter(longitude < 96) %>% rt
```

#### Datum
```{r datum_tally}
datum_tally <- tfa_occ %>%
  dplyr::group_by(datum) %>%
  dplyr::tally() %>%
  dplyr::arrange(desc(n)) %>% 
  ungroup()
datum_tally %>% rt
```

There are `r nrow(datum_tally)` different datums used across all distinct fauna records. 

```{r datum_blank}
datum_blank<- tfa_occ %>% 
    filter(datum == "")
```

There are `r nrow(datum_blank)` distinct fauna records with missing datum. These will be defaulted to WGS84.

#### Taxonomic caveats

Fauna occurrences link to the name that was current / legal at the time.
Occurrence query should show hints linking to current / legal names and their history.

`zone` and `datum` are standard names expected by BioSys.

#### Missing NameID

```{r show_tfa_occ_missing_name_id}
tfa_occ_no_nameid <- tfa_occ %>% 
    filter(is.na(name_id))
tfa_occ_no_nameid %>% rt
```

There are `r nrow(tfa_occ_no_nameid)` distinct scientific fauna names missing a NameID.

#### Missing Species Code

```{r show_tfa_occ_missing_species_code}
tfa_occ_no_specode <- tfa_occ %>% 
    filter(is.na(species_code)) 
tfa_occ_no_nameid %>% rt
```

There are `r nrow(tfa_occ_no_specode)` distinct scientific fauna names missing a Species
Code.Any records listed here need to be fixed in the original Threatened Fauna database.

### Observation occurrence mapping

Occurrence criteria were manually mapped for each variable, therefore they need
to be checked to confirm whether the mapping is correct. 

Landforms: These terms were mapped to 'umbrella' terms which generally follow the 
morphological types listed in McDonald et al. (1998, p13). However, some of the terms 
could not be mapped as they are vegetation types (e.g. FOR = Forest) and not landform 
types. 

McDonald, R.C., Isbell, R.F., Speight, J.G., Walker, J., and Hopkins, M.S. (1998)
Australian Soil and Land Survey - Field Handbook, Second Addition. CSIRO, Canberra, 
Australia.

Secondary signs: 'Definite signs' was not mapped

Sample destination: Was manually mapped to a generic field for its location and
the specific location added to the sample label field as free text. We have done
this because, combined with flora, there are \> 100 unique locations for sample
destination, which would make a very long drop down menu.

The manual mapping needs to be spot checked and approved before the manual mapping
can be considered complete.

```{r show_tfl_lookup_mappings}
tfa_confidence %>% rt
tfa_landcrit %>% rt
tfa_det_meth %>% rt
tfa_sec_sign %>% rt
tfa_repmap %>% rt
tfa_samptype %>% rt
tfa_sampdest %>% rt
```

### Occurrence observations with no matching TAE

Below are occurrence observations which do not have a corresponding TAE for 
them to be assigned to. 

```{r show_occ_obs_no_matching_tae}
missing_tae_phys_sample <- tfa_phys_sample_complete %>% 
  dplyr::anti_join(tfa_tae, by = "source_id")
missing_tae_anim_obs <- tfa_anim_obs_complete %>% 
  dplyr::anti_join(tfa_tae, by = "source_id")
missing_tae_veg_class <- tfa_veg_class_complete %>% 
  dplyr::anti_join(tfa_tae, by = "source_id")
missing_tae_hab_comp <- tfa_hab_comp_complete %>% 
  dplyr::anti_join(tfa_tae, by = "source_id")

missing_tae_phys_sample %>% rt
missing_tae_anim_obs %>% rt
missing_tae_veg_class %>% rt
missing_tae_hab_comp %>% rt
```
There are no results in the above tables because the occ_observations without a matching
tae were removed prior to migration to prevent errors in the upload. See section...

### `tfl_tae` occurrence observations not in `tsc_tae_observations`

Any record differences in the following table indicate occurrence observations in TFL 
that were not migrated into TSC.

```{r show_occ_obs_summary}
make_tfa_tae_occ_obs_summary <-
  . %>% nrow() %>% as.data.frame() %>% magrittr::set_colnames("TFA")

tfa_phys_sample_sum <-
  tfa_phys_sample %>% make_tfa_tae_occ_obs_summary
tfa_anim_obs_sum <-
  tfa_anim_obs %>% make_tfa_tae_occ_obs_summary
tfa_veg_class_sum <-
  tfa_veg_class %>% make_tfa_tae_occ_obs_summary
tfa_hab_comp_sum <-
  tfa_hab_comp %>% make_tfa_tae_occ_obs_summary

make_tsc_occ_obs_summary <- function(data, cn) {
  data %>%
    dplyr::select(obstype) %>%
    dplyr::filter(str_detect(obstype, cn)) %>%
    nrow() %>%
    as.data.frame %>%
    magrittr::set_colnames("TSC")
}

tsc_phys_sample_sum <-
  tsc_tae_observations %>% make_tsc_occ_obs_summary("PhysicalSample")
tsc_anim_obs_sum <-
  tsc_tae_observations %>% make_tsc_occ_obs_summary("AnimalObservation")
tsc_veg_class_sum <-
  tsc_tae_observations %>% make_tsc_occ_obs_summary("VegetationClassification")
tsc_hab_comp_sum <-
  tsc_tae_observations %>% make_tsc_occ_obs_summary("HabitatComposition")


tfa_occ_obs_sum <- rbind(
  tfa_phys_sample_sum,
  tfa_anim_obs_sum,
  tfa_veg_class_sum,
  tfa_hab_comp_sum
  #tfl_plant_count_sum
)

tsc_occ_obs_sum <- rbind(
  tsc_phys_sample_sum,
  tsc_anim_obs_sum,
  tsc_veg_class_sum,
  tsc_hab_comp_sum
  #tsc_plant_countsum
)

occ_obs_summary <- tfa_occ_obs_sum %>%
  cbind(tsc_occ_obs_sum) %>%
  cbind(Obstype = c("PhysicalSample", "HabitatCondition", "AreaAssessment", "HabitatComposition")) %>% # PlantCount
  dplyr::select("Obstype", everything())

occ_obs_summary %>% rt

```

#### Spot check occurrence observations


#### Trust level of occurrence records

Currently, we assume that all occurrence records in the legacy databases are 
trustworthy. If this weren't the case, this analysis should exclude the 
non-trustworthy records.

### `tfa_occ` occurrences not in `tfa_tae`

Any records in the following table indicate occurrences in `tfa_occ` that are not 
in `tfa_tae`.

```{r show_tfa_tae_missing_occurrences}
missing_occ_tfa_tae <- tfa_occ %>%
  dplyr::anti_join(tfa_tae, by = c("id" = "source_id")) 

missing_occ_tfa_tae %>% rt

missing_occ_tfa_tae_unique <- missing_occ_tfa_tae %>%
  dplyr::select(name_id) %>%
  distinct() 

missing_occ_tfa_tae_unique %>% rt 
```

There are `r nrow(missing_occ_tfa_tae)` occurrences missing from `tfa_tae`when
compared to `tfa_occ`. 

These missing occurrences come from `r nrow(missing_occ_tfa_tae_unique)` unique species. 

The occurrences listed were likely not migrated because they do not contain a name_id 
and/or a location which are a requirement of a tfa taxon area encounter.

The table below is a tally of mismatching occurrences by taxon and confirms the two
missing occurrences identified above.

```{r make_tally_tfa_occ_tae}
tfa_occ_tally <- tfa_occ %>%
  dplyr::group_by(name_id) %>% 
  dplyr::tally() %>%
  dplyr::arrange(desc(n)) %>% 
  ungroup()

tfa_tae_tally <- tfa_tae %>%
  dplyr::group_by(taxon) %>% 
  dplyr::tally() %>%
  dplyr::arrange(desc(n)) %>% 
  ungroup()

tfa_occ_tally %>%
  dplyr::rename(tfa_occ = n) %>% 
  left_join(tfa_tae_tally, by = c("name_id" = "taxon")) %>% 
  dplyr::rename(tfa_tae = n) %>% 
  filter(tfa_occ != tfa_tae) %>% rt
```

### `tfa_tae`occurrences not in `tsc_tae`

Any records in the following table indicate occurrences in `tfa_tae` that were not
migrated into `tsc_occ_fauna`.

```{r show_name_mismatches_tfa_tae_to_tsc_tae}
missing_occ_tfa_tae_tsc <- tfa_tae %>% 
  dplyr::anti_join(tsc_occ_fauna, by = "source_id")

missing_occ_tfa_tae_tsc %>% rt

missing_occ_tfa_tae_tsc_unique <- missing_occ_tfa_tae_tsc %>% 
  dplyr::select(taxon) %>% 
  distinct()

missing_occ_tfa_tae_tsc_unique %>% rt
```

There are `r nrow(missing_occ_tfa_tae_tsc)` taxon records missing from `tsc_occ_fauna` when 
compared to `tfa_tae`. 

These records are attributed to `r nrow(missing_occ_tfa_tae_tsc_unique)` unique species. 

The occurrences listed were likely not migrated because they do not contain lat or long 
data which is a requirement for valid taxon area encounters.

The table below is a tally of mismatching occurrences by taxon. There are no mismatches but
there are five duplicated records. 

```{r make_tally_tfa_tae_tsc}
tfa_tae_tally <- tfa_tae %>%
  dplyr::group_by(taxon) %>% 
  dplyr::tally() %>%
  dplyr::arrange(desc(n)) %>% 
  ungroup()

tsc_occ_tally <- tsc_occ_fauna %>%
  dplyr::group_by(taxon) %>% 
  dplyr::tally() %>%
  dplyr::arrange(desc(n)) %>% 
  ungroup()

tfa_tae_tsc_tally <- tfa_tae_tally %>%
  dplyr::rename(tfa_tae = n) %>% 
  left_join(tsc_occ_tally,by = "taxon") %>% 
  dplyr::rename(tsc_occ = n) %>% 
  filter(tfa_tae != tsc_occ)
# tfa_tae_tsc_tally %>% rt 
# TODO cast sfc to tbl_df
```

### `tfa_occ` names not in `tfa_tae`

Any records in the following table indicate names in `tfa_occ` that are not 
in `tfa_tae`.

```{r show_name_mismatches_tfa_occ_to_tfa_tae}
missing_taxa_tfa_tae <- tfa_occ %>% 
    dplyr::anti_join(tfa_tae, by = c("name_id" = "taxon"))
```

There are `r nrow(missing_taxa_tfa_tae)` taxon records missing from 
`tfa_tae` when compared to `tfa_occ`.

### `tfa_tae`names not in `tsc_occ_fauna`

Any records in the following table indicate names in `tfa_tae` that were not
migrated into `tsc_occ_fauna`.

```{r show_missing_occurrences_tfa_tae_to_tsc_tae}
missing_taxa_tae_tsc <- tfa_tae %>%
  dplyr::anti_join(tsc_occ_fauna, by = "taxon") 

missing_taxa_tae_tsc %>% rt

missing_taxa_tae_tsc_unique <- missing_taxa_tae_tsc %>% 
    dplyr::select(taxon) %>% 
    distinct()
```

There are `r nrow(missing_taxa_tae_tsc)` unique occurrences missing from
`tsc_occ_fauna` when compared to `tfa_tae`. 

These missing occurrences come from `r nrow(missing_taxa_tae_tsc_unique)` 
unique species.

## Conservation Documents

## Fire History

## Conservation Threats and Actions

# Upload to data catalogue
The [compiled version of this workbook](https://data.dpaw.wa.gov.au/dataset/79e90d7b-33a3-4aa0-8634-8a12033eb21d/resource/2b136da7-35cf-44a5-b29e-9f568176b7ad/download/eda_fauna.html) is uploaded to the 
[Threatened Fauna Dataset](https://data.dbca.wa.gov.au/dataset/threatened-and-priority-fauna-database) 
on the DBCA data catalogue.

The manual mapping of conservation criteria, plus all legacy data is also
uploaded as CSV snapshots.

```{r upload_data_catalogue, message=FALSE}
# This workbook
upload_file_to_ckan("2b136da7-35cf-44a5-b29e-9f568176b7ad", "EDA_fauna.html")

# Manual mapping of conservation criteria
upload_file_to_ckan("e1c3119b-f44d-4244-8915-21097bd16b90", 
                    here::here("tfa_conscrit_w_tsc.csv"))

# Legacy TFA data
d <- ckanr::package_show("threatened-and-priority-fauna-database")
upload_to_ckan(
  tfa_cons_listings, "Threatened Fauna Conservation Status Gazettal", d$id,
  resource_id = "ac089664-de5a-4efa-af3c-ada0ec77ef1f"
)
# same for other TFA legacy data, copy over from data_etl_fauna.Rmd
```
