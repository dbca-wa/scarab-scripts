---
title: "Data ETL: Fauna"
author: "Florian Mayer and Milly Piggott, DBCA"
date: "`r Sys.time()`"
always_allow_html: yes
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    fig_width: 10
    fig_height: 6
    code_folding: hide
    theme: lumen
  pdf_document: default
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = TRUE)
source("helpers.R")
```

# Context
This workbook summarises the legacy data migration and QA for the Threatened
and Priority Fauna database (TFA).

<img src="https://data.dpaw.wa.gov.au/dataset/79e90d7b-33a3-4aa0-8634-8a12033eb21d/resource/98588a4e-b3af-452b-bbf4-f63ca7697752/download/tsc-progress.jpg" 
width="100%" alt="Legacy data migration and QA diagram"/>

By default, all code blocks are collapsed to provide better readability to the
non-technical audience. Feel free to expand the code blocks to view the process.

The code for all SCB workbooks is under version control at 
[github](https://github.com/dbca-wa/scarab-scripts).


# Extract and transform legacy Data from TFA
Data from the Threatened Fauna Database (TFA) is downloaded from the 
[TFA dataset](https://data.dpaw.wa.gov.au/dataset/threatened-and-priority-fauna-database) 
on the DBCA data catalogue, then extracted and transformed.

## Taxonomy
```{r load_tfa, message=FALSE}
tfa_data <- dl_mdbzip("66efb68d-8f05-4bfc-af14-5d1a381d0cf2")
names_tfa <- as.data.frame(names(tfa_data))

snapshot_last_updated <- "66efb68d-8f05-4bfc-af14-5d1a381d0cf2" %>%
  ckanr::resource_show() %>%
  magrittr::extract2("last_modified") %>%
  lubridate::as_datetime() %>%
  lubridate::with_tz("Australia/Perth")

# Cached data from TSC - delete to force refresh
datafile_tsc_fauna <- here::here("data", "etl_fauna_tsc.Rda")

# Lookup tables
shires <- tfa_data$Shires %>%
  dplyr::transmute(
    lga_id = LGACode %>% as.integer(),
    shire_name = LGAName %>% as.character(),
    shire_label = LGAName2 %>% as.character()
  )

tenure <- tfa_data$`Land Tenure` %>%
  dplyr::transmute(
    tenure_id = TenCode %>% as.character(),
    tenure = Tenure %>% as.character()
  )

vegetation_types <- tfa_data$`Vegetation Types` %>%
  dplyr::transmute(
    vegetation_type_id = VegCode %>% as.character(),
    vegetation_type = VegTypeName %>% as.character()
  )

certainty <- tfa_data$Certainty %>%
  dplyr::transmute(
    certainty_id = Code %>% as.integer(),
    certainty = Certainty %>% as.character()
  )

users <- tibble::tibble(
  username = c(
    "AmyM", "AbbyT", "BrianaWingfield",
    "ChristineFreegard", "GeorginaA", "KellieMantle",
    "NickyMarlow", "PeterMawson", "PeterOrell"
  ),
  initials = c(
    "AM", "AT", "BW",
    "CF", "GA", "KM",
    "NM", "PM", "PO"
  ),
  name = c(
    "Amy Mutton", "Abby Thomas", "Briana Wingfield",
    "Christine Freegard", "Georgina Anderson", "Kellie Mantle",
    "Nicky Marlow", "Peter Mawson", "Peter Orell"
  )
)

# Taxonomy
phylo_class <- tfa_data$`Class List` %>%
  dplyr::transmute(
    phylo_class_id = ClassCode %>% as.character(),
    phylo_class_common_name = ClassName %>% as.character(),
    phylo_class_scientific_name = Class %>% as.character(),
    order = ClassOrder %>% as.character()
  ) %>%
  dplyr::arrange(order)

phylo_group <- tfa_data$`Group List` %>%
  dplyr::transmute(
    phylo_group_id = Group %>% as.integer(),
    phylo_group_name = GroupName %>% as.character(),
    phylo_class_id = Class %>% as.character()
    # order = GroupOrder %>% as.character()
  ) %>%
  dplyr::left_join(phylo_class, by = "phylo_class_id")
# skimr::skim(group)

species_notes <- tfa_data$`Species Notes` %>%
  dplyr::transmute(
    species_code = SpCode %>% as.character(),
    species_notes = Notes %>% as.character()
  )

category <- tfa_data$`Category List` %>%
  dplyr::transmute(
    category_id = Category %>% as.character(),
    phylogenetic_category = CategoryName %>% as.character()
  )

landform <- tfa_data$`Landform` %>%
  dplyr::transmute(
    Landform_id = LFCode %>% as.character(),
    Landform = Landform %>% as.character()
  )

secondary_signs <- tfa_data$`Secondary Signs` %>% 
  dplyr::transmute(
    sign = Sign %>% as.character()
  )
readr::write_csv(secondary_signs, path = here::here("data", "secondary_signs_data.csv")) 

# TODO species notes
species <- tfa_data$`Species List` %>%
  dplyr::transmute(
    species_code = SpCode %>% as.character(),
    old_species_code = OldCode %>% as.character(),
    short_code = ShCode %>% as.character(),
    name_id = NameID %>% as.character(),
    scientific_name = ScName %>% as.character(),
    common_name = ComName %>% as.character(),
    phylo_group_id = PhyloGroup %>% as.integer(),
    family = Family %>% as.character(),
    genus = Genus %>% as.character(),
    species = Species %>% as.character(),
    authority_species = Authority.sp %>% as.character(),
    subspecies = Subspecies %>% as.character(),
    authority_subspecies = Authority.ssp %>% as.character(),
    # file_number_calm = CALMFileNum %>%
    #   as.character() %>%
    #   map(~ as_filenumber(., prefix = "CALM")),
    # file_number_dec = DECFileNum %>%
    #   as.character() %>%
    #   map(~ as_filenumber(., prefix = "DEC")),
    # file_number_dpaw = DPaWFileNum %>%
    #   as.character() %>%
    #   map(~ as_filenumber(., prefix = "DPAW")),
    # file_number_dbca = DBCAFileNum %>%
    #   as.character() %>%
    #   map(~ as_filenumber(., prefix = "DBCA")),
    category_id = Category %>% as.character(),
    origin = Origin %>% as.character(), # N - native, I - introduced
    # region_id_list = Region %>% map(~ as.list(strsplit(., ",")[[1]] %>% as.integer())),
    taxon_id = TaxonId %>% as.logical()
    # translocated = Trans %>% as.character(), # E - extant, T - translocated
    # accept_new_records = Incl %>% as.logical(), # only FALSE in old records
    # species_can_be_trapped = Trap %>% as.logical(),
    # only_sighting_type_surveys = Sight %>% as.logical(),
    # could_have_nest_box = Nbox %>% as.### Datalogical(),
    # could_display_secondary_signs = Sign %>% as.logical(),
    # can_associate_band_number = BANo %>% as.logical(),
    # buffer = Buffer %>% as.character(), # NA 0 1 2 3 - unused
    # estimated_lifespan = EST.LIFE %>% as.integer() # NA  0 10  7 15  6  8
  ) %>%
  dplyr::left_join(phylo_group, by = "phylo_group_id") %>%
  dplyr::left_join(species_notes, by = "species_code") %>%
  dplyr::left_join(category, by = "category_id") 
# species_skim <- skimr::skim(species)
# print(species_skim)
# DT::datatable(species)

# Just the essentials: species code, name_id, names.
species_names <- species %>%
  dplyr::select(species_code, name_id, scientific_name, common_name)

resolution <- tfa_data$Resolution %>%
  dplyr::transmute(
    resolution_id = ResCode %>% as.integer(),
    resolution_geographic_coords = ResolutionLL %>% as.character(),
    resolution_projected_coords = ResolutionUTM %>% as.character()
  )

resolution_m <- tibble::tibble(
  resolution_id = c(1, 2, 3, 4, 5, 6),
  accuracy = c(50, 100, 1000, 10000, 50000, 100000)
)
```

## Conservation listings
```{r load_tfa_cons, message=FALSE}
# TFA conservation lists
tfa_cons_lists <- tfa_data$`Listing Names` %>%
  dplyr::transmute(
    list_code = ListCode %>% as.character(),
    list_name = ListName %>% as.character(),
    list_order = ListOrder %>% as.integer()
  ) %>%
  dplyr::arrange(list_order) %>%
  dplyr::glimpse()

dec_tfa_cons_lists <- tfa_data$`DEC List Names` %>%
  dplyr::transmute(
    dec_listing_id = DECCode %>% as.character(),
    dec_listing_name = DECList %>% as.character(),
    dec_listing_order = DECOrder %>% as.integer()
  ) %>%
  dplyr::arrange(dec_listing_order)
# dec_tfa_cons_lists %>% skim()
# dec_tfa_cons_lists %>% dplyr::glimpse()

# make_coldef(listing_category)
tfa_cons_cat <- tfa_data$`Listing Category` %>%
  dplyr::transmute(
    list_code = ListCode %>% as.character(),
    category_code = StatCode %>% as.character(),
    category_label = Status %>% as.character(),
    status_expand = StatusExpand %>% as.character(),
    explanations = Explanations %>% as.character(),
    notes = Notes %>% as.character(),
    order = Order %>% as.integer(),
    dec_listing_id = DECCode %>% as.character()
  ) %>%
  dplyr::arrange(order) %>%
  dplyr::left_join(tfa_cons_lists, by = "list_code") %>%
  dplyr::left_join(dec_tfa_cons_lists, by = "dec_listing_id")

# TFA taxon conservation listings
tfa_cons_listings <- tfa_data$Gazettal %>%
  dplyr::transmute(
    species_code = SpCode %>% as.character(),
    list_code = ListCode %>% as.character(),
    category_code = StatCode %>% as.character(),
    population = Popn %>% as.character(),
    criteria_code = Reasons %>% as.character(),
    authority = AUTHORITY %>% as.character(),
    gazetted_on = DateList %>% parse_date_time(., orders = orders, tz = tz),
    delisted_on = DateDeList %>% parse_date_time(., orders = orders, tz = tz),
    last_reviewed_on = DateReviewed %>% parse_date_time(., orders = orders, tz = tz),
    reviewed_by = INTERIM %>% as.character(),
    review_outcome = TRANSLOCATION %>% as.character(),
    comments = Comments %>% as.character()
  ) %>%
  dplyr::left_join(species_names, by = "species_code") %>%
  tibble::rowid_to_column("source_id") %>% 
  dplyr::mutate(source_id = source_id %>% as.character())
# tfa_cons_listings %>% skim()
# tfa_cons_listings %>% head(10) %>% DT::datatable()

# Legacy conservation criteria are free text in condensed writing.
# Write to CSV for manual mapping to TSC criteria PKs.
all_crit_map <- tfa_cons_listings %>%
  dplyr::group_by(list_code) %>%
  dplyr::distinct(criteria_code) %>%
  dplyr::arrange(list_code, criteria_code) %>%
  dplyr::select(list_code, criteria_code) %>% 
  ungroup()
readr::write_csv(all_crit_map, path = here::here("data", "all_tfa_conscrit.csv"))
```

## Occurrences

Occurance data is extracted and transformed. 

Mallee Fowl data is extracted seperatly and exported, to be stored as a csv file on the data catalogue 

[Mallee Fowl](https://data.dpaw.wa.gov.au/dataset/79e90d7b-33a3-4aa0-8634-8a12033eb21d/resource/c636bbdd-7926-4c10-8032-6c7fa5a7e318/download/malleefowl_data.csv)

```{r load_tfa_occ, message=FALSE}
default_date <- lubridate::parse_date_time("1900-01-01 00:00:00",
                                           orders = "ymd HMS",
                                           tz = tz)
tfa_rec <- tfa_data$`Fauna Records` 
names_tfa_rec <- (as.data.frame(names(tfa_rec)))

# taxon occurances
tfa_occ <- tfa_rec %>% dplyr::transmute(
    id = DBNo %>% as.integer(),
    district_db = DistDB %>% as.integer(),
    district_db_no = DistDBNo %>% as.character(),
    species_code = SpCode %>% as.character(),
    # name_id = NameId %>% as.character(), # they're all NA
    orig_date = Date,
    orig_time = Time,
    o_date = ifelse(
        Date == "",
        default_date,
        lubridate::parse_date_time2(Date, orders, tz = tz, cutoff_2000 = 19L)
        ) %>% lubridate::as_datetime(.) %>% with_tz(tzone = tz),
    o_time = ifelse(
        Time == "",
        default_date,
        lubridate::parse_date_time2(Time, orders, tz = tz, cutoff_2000 = 19L)
        ) %>% lubridate::as_datetime(.) %>% with_tz(tzone = tz),
    datetime = ifelse(
        is.na(o_date),
        default_date,
        ifelse(
            is.na(o_time),
            o_date,
            o_date + hours(hour(o_time)) + minutes(minute(o_time))
        )) %>% lubridate::as_datetime(.) %>% with_tz(tzone = tz),
    observer_name = Observer %>% as.character(),
    observer_role = OrgRole %>% as.character(),
    observer_address = Address %>% as.character(),
    observer_phone = Phone %>% as.character(),
    certainty_id = Certainty %>% as.integer(),
    number_seen = NumSeen %>% as.integer(), # sum of number_*
    animal_features = Features %>% as.character(),
    number_adult_males = AdultM %>% as.integer(),
    number_adult_females = AdultF %>% as.integer(),
    number_adult_unknown = AdultU %>% as.integer(),
    number_juvenile_males = JuvM %>% as.integer(),
    number_juvenile_females = JuvF %>% as.integer(),
    number_juvenile_unknown = JuvU %>% as.integer(),
    location_id = Location. %>% as.character(),
    location_name = LocName %>% as.character(),
    tenure_id = TenCode %>% as.character(),
    lga_id = LGACode %>% as.integer(),
    district_id = DistrictNo %>% as.character(),
    site_comment = Site %>% as.character(),
    latitude = Lat %>% as.double(),
    longitude = Long %>% as.double(),
    zone = MapZone %>% as.character(),
    northing = SightNorth %>% as.character(),
    easting = SightEast %>% as.character(),
    datum = Datum %>% as.character(),
    resolution_id = Resolution %>% as.integer(),
    landform_id = Landform %>% as.character(),
    vegetation_type_id = VegType %>% as.character(),
    fire_history = Fire %>% as.character(),
    associated_flora_species_1 = Sp1 %>% as.character(),
    associated_flora_species_2 = Sp2 %>% as.character(),
    associated_flora_species_3 = Sp3 %>% as.character(),
    associated_flora_species_4 = Sp4 %>% as.character(),
    associated_flora_species_5 = Sp5 %>% as.character(),
    associated_flora_species_6 = Sp6 %>% as.character(),
    observation_method = ObservMethod %>% as.character(),
    observation_type = ObservType %>% as.character(),
    secondary_signs = SecSign %>% as.character(),
    observation_comments = Observation %>% as.character(),
    breeding_status = Breeding %>% as.character(),
    specimen_status = Specimen %>% as.character(),
    species_id_confirmed_by = Identification %>% as.character(),
    map_provided = Map %>% as.character(), # TODO parse bool
    mudmap_provided = MudMap %>% as.character(), # TODO parse bool
    photo_taken = Photo %>% as.character(), # TODO parse bool
    notes = Notes %>% as.character(),
    comments = Comments %>% as.character(),
    entered_by = EnName %>% as.character(),
    entered_on = parse_date_time(EnDate, orders = orders, tz = tz),
    changed_by = ChName %>% as.character(),
    changed_on = parse_date_time(ChDate, orders = orders, tz = tz),
    specimen_voucher_exists = SpVoucher %>% as.logical(),
    specimen_voucher_location = SpHeld %>% as.character(), # specimen catalogue
    specimen_voucher_catalogue_number = SpCatNum %>% as.character(),
    occurrence_not_published = UnPublished %>% as.logical(),
    occurrence_citation = ReportTitle %>% as.character(),
    occurrence_citation_author = Author %>% as.character(),
    # malleefowl_MFeggsH = MFeggsH %>% as.character(),
    # malleefowl_MFeggsU = MFeggsU %>% as.character(),
    # malleefowl_MFmoundU = MFmoundU %>% as.character(),
    # malleefowl_MFmoundCA = MFmoundCA %>% as.character(),
    # malleefowl_MFmoundRA = MFmoundRA %>% as.character(),
    # malleefowl_MFmoundI = MFmoundI %>% as.character(),
    # malleefowl_MFMage = MFMage %>% as.character(),
    # malleefowl_MFMdiam = MFMdiam %>% as.character(),
    # malleefowl_MFMheight = MFMheight %>% as.character(),
    # malleefowl_MFMwidth = MFMwidth %>% as.character(),
    # malleefowl_MFMdepth = MFMdepth %>% as.character(),
    # malleefowl_MFMsoil = MFMsoil %>% as.character(),
    # malleefowl_MFMcomment = MFMcomment %>% as.character(),
    # malleefowl_MFextract = MFextract %>% as.character()
    # Field* are empty, skipping:
    # Field1 = Field1 %>% as.character(),
    # Field2 = Field2 %>% as.character(),
    # Field3 = Field3 %>% as.character(),
    # Field4 = Field4 %>% as.character(),
    # Field5 = Field5 %>% as.character()
  ) %>% 
  dplyr::left_join(shires, by = "lga_id") %>%
  dplyr::left_join(tenure, by = "tenure_id") %>%
  dplyr::left_join(vegetation_types, by = "vegetation_type_id") %>% ## there are duplicates in this dataframe
  dplyr::left_join(certainty, by = "certainty_id") %>%
  dplyr::left_join(species_names, by = "species_code") %>%
  dplyr::left_join(resolution_m, by = "resolution_id") %>%
  invisible() 

## Create occurance data tables for each card in TSC
hab_comp <- tfa_occ %>%
  dplyr::filter(!is.na(name_id) & !is.na(latitude) & !is.na(longitude) & name_id!=0) %>% 
  dplyr::transmute(
    source = 10,
    source_id = id,
    landform_id = landform_id)

hab_comp %>%
  dplyr::select(landform_id) %>%
  distinct() %>% 
  readr::write_csv(path = here::here("data", "tfa_landcrit.csv"))

veg_class <- tfa_occ %>%
  dplyr::filter(!is.na(name_id) & !is.na(latitude) & !is.na(longitude) & name_id!=0) %>% 
  dplyr::transmute(
    source = 10,
    source_id = id,
    vegetation_code = vegetation_type_id,
    vegetation_type = vegetation_type) #parse as free text

ass_species <- tfa_occ %>%
  dplyr::filter(!is.na(name_id) & !is.na(latitude) & !is.na(longitude) & name_id!=0) %>% 
  dplyr::transmute(
    source = 10,
    source_id = id,
    associated_species_1 = associated_flora_species_1,
    associated_species_2 = associated_flora_species_2,
    associated_species_3 = associated_flora_species_3,
    associated_species_4 = associated_flora_species_4,
    associated_species_5 = associated_flora_species_5,
    associated_species_6 = associated_flora_species_6) #parse as free text
    
anim_obs <- tfa_occ %>%
  dplyr::filter(!is.na(name_id) & !is.na(latitude) & !is.na(longitude) & name_id!=0) %>% 
  dplyr::transmute(
    source = 10,
    source_id = id,
    species_id_confidence = certainty,
    observation_details = glue::glue(
        "Number seen: {number_seen};\n",
        "Detection: {observation_method}: {observation_type};\n",
        "Comments: {observation_comments}"), # Card is free text
    distinctive_features = animal_features,
    number_of_adult_males = number_adult_males,
    number_of_adult_females = number_adult_females,
    number_of_adult_unknown = number_adult_unknown,
    number_of_juvenile_males = number_juvenile_males,
    number_of_juvenile_females = number_juvenile_females,
    number_of_juvenile_unknown = number_juvenile_unknown,
    detection_method = observation_type,
    secondary_signs = secondary_signs,
    reproductive_maturity = breeding_status)

anim_obs %>%
  dplyr::select(species_id_confidence) %>%
  distinct() %>% 
  readr::write_csv(path = here::here("data", "tfa_id_conf.csv"))

anim_obs %>%
  dplyr::select(reproductive_maturity) %>%
  distinct() %>% 
  readr::write_csv(path = here::here("data", "tfa_repmat.csv"))

anim_obs %>%
  dplyr::select(secondary_signs) %>%
  distinct() %>% 
  readr::write_csv(path = here::here("data", "tfa_secsign.csv"))

anim_obs %>%
  dplyr::select(detection_method) %>%
  distinct() %>% 
  readr::write_csv(path = here::here("data", "tfa_detmeth.csv"))

anim_obs %>%
  dplyr::select(detection_type) %>%
  distinct() %>% 
  readr::write_csv(path = here::here("data", "tfa_dettype.csv"))

phys_sample <- tfa_occ %>% 
  dplyr::filter(!is.na(name_id) & !is.na(latitude) & !is.na(longitude) & name_id!=0) %>% 
  dplyr::transmute(
    source = 10,
    source_id = id,
    sample_type = specimen_status,
    specimen_voucher_exists = specimen_voucher_exists, # This column is confusing- what does it mean?
    sample_destination = specimen_voucher_location,
    sample_label = glue::glue("[{specimen_voucher_location}]{specimen_voucher_catalogue_number}"))

phys_sample %>%
  dplyr::select(sample_destination) %>%
  distinct() %>% 
  readr::write_csv(path = here::here("data", "tfa_sampdest.csv"))

phys_sample %>%
  dplyr::select(sample_type) %>%
  distinct() %>% 
  readr::write_csv(path = here::here("data", "tfa_samptype.csv"))

## Put Malleefowl in separate csv file and add to data catalogue
malleefowl_data <- tfa_rec %>% dplyr::transmute(
  id = DBNo %>% as.integer(),
  malleefowl_MFeggsH = MFeggsH %>% as.character(),
  malleefowl_MFeggsU = MFeggsU %>% as.character(),
  malleefowl_MFmoundU = MFmoundU %>% as.character(),
  malleefowl_MFmoundCA = MFmoundCA %>% as.character(),
  malleefowl_MFmoundRA = MFmoundRA %>% as.character(),
  malleefowl_MFmoundI = MFmoundI %>% as.character(),
  malleefowl_MFMage = MFMage %>% as.character(),
  malleefowl_MFMdiam = MFMdiam %>% as.character(),
  malleefowl_MFMheight = MFMheight %>% as.character(),
  malleefowl_MFMwidth = MFMwidth %>% as.character(),
  malleefowl_MFMdepth = MFMdepth %>% as.character(),
  malleefowl_MFMsoil = MFMsoil %>% as.character(),
  malleefowl_MFMcomment = MFMcomment %>% as.character(),
  malleefowl_MFextract = MFextract %>% as.character()
  ) %>% 
  na.omit() %>% 
  dplyr::left_join(tfa_occ,by = "id")
  readr::write_csv(malleefowl_data, path = here::here("data", "malleefowl_data.csv"))
  
# Create taxon area encounter
tfa_tae <- tfa_occ %>%
  dplyr::filter(!is.na(name_id) & !is.na(latitude) & !is.na(longitude) & name_id!=0) %>% 
  # dplyr::left_join(taxa, by="name_id") %>% 
  dplyr::transmute(
    taxon = name_id,
    code = location_id,
    name = location_name,
    description = glue::glue(
        "Observer: {observer_name} ({observer_role}) {observer_address} {observer_phone}\n",
        "Species ID confirmation: {species_id_confirmed_by}\n",
        "Site comments: {site_comment}\n",
        "Curator comments: {comments}\n",
        "District: {district_db} {district_db_no}\n",
        "Shire: {shire_name} {shire_label}\n",
        "Tenure: {tenure}\n",
        "LGA ID: {lga_id}\n",
        "District ID: {district_id}\n",
        "Vegetation type: {vegetation_type}\n",
        "Fire history: {fire_history}\n",
        "Date entered: {entered_on} {entered_by}\n",
        "Date changed: {changed_on} {changed_by}\n",
        "Not published: {occurrence_not_published}\n",
        "Occurrence citation: {occurrence_citation} {occurrence_citation_author}"
        ),
    source = 10,
    source_id = id,
    encounter_type = 1, # https://tsc.dbca.wa.gov.au/admin/occurrence/encountertype/1/change/ = opportunistic 
    encountered_on = glue::glue("{datetime}+08:00"),
    encountered_by = 1,
    area_type = 30,
    geolocation_capture_method='gps-point',
    accuracy = accuracy,
    point = glue::glue("SRID=4326;POINT({longitude} {latitude})"),
    # observation_details = glue::glue("{observation_method} {observation_type} {secondary_signs} {observation_comments}")
  ) %>%
  dplyr::arrange(taxon)
   
names_tfa_tae <- (as.data.frame(names(tfa_tae)))

occ_file <- here::here("data", "occ.Rdata")
save(tfa_occ, tfa_tae, file=occ_file)
if (file.exists(occ_file)) load(occ_file)

```

## Recovery Actions and Plans
``` {r load_tfa_rec}
tfa_act <- tfa_data$`Recovery Actions` %>%
  dplyr::transmute(id = ID %>% as.integer(),
                   actions = Recovery.Actions %>% as.character())

tfa_pla <- tfa_data$`Recovery Plans` %>%
  dplyr::transmute(species_code = SpCode %>% as.character(),
                   program_no = ProgramNo %>% as.character(),
                   recovery_plan = RecoveryPlan %>% as.character(),
                   national_state = NationalorState %>% as.character(),
                   year_approved = YearApproved %>% as.character(),
                   objectives = Objectives %>% as.character(),
                   action_types = ActionTypes %>% as.character(),
                   research_topics = ResearchTopics %>% as.character(),
                   recovery_team = RecoveryTeam %>% as.character(),
                   active = Active %>% as.character(),
                   rt_national_state = RTNationalorState %>% as.character(),
                   lead_org = LeadOrg %>% as.character(),
                   chair_org = ChairOrg %>% as.character(),
                   chair_name = ChairName %>% as.character(),
                   chair_contact = ChairContact %>% as.character(),
                   exec_name = ExecOName %>% as.character(),
                   exec_contact = ExecOContact %>% as.character(),
                   membership = Membership %>% as.character(),
                   rt_file_number = RTFileNumber %>% as.character())
```

## Research priorities and topics
``` {r load_tfa_res}
tfa_resp <- tfa_data$`Research Priorities` %>%
  dplyr::transmute(species_code = SpCode %>% as.character(),
                   research_priority = ResearchPriority %>% as.character(),
                   undertaken = Undertaken %>% as.character(),
                   comments = Comments %>% as.character())

tfa_rest <- tfa_data$`Research Topics` %>%
  dplyr::transmute(id = ID %>% as.integer(),
                   research_topics = Research.Topics %>% as.character())


readr::write_csv(tfa_resp, path = here::here("data", "research_priorities_data.csv")) # this has been added to the data catelogue already
readr::write_csv(tfa_rest, path = here::here("data", "research_topics_data.csv"))
```

# Extract and transform conservation criteria Data from TSC
Conservation criteria from TSC are downloaded from the TSC API 
and transformed into a usable format for manual mapping to TFA.

A manual step annotated legacy conservation criteria exported from TFA to 
conservation criteria IDs in TSC in a spreadsheet.

``` {r extract_tsc_cons_criteria, message=FALSE}
tsc_cons_list <- "conservationlist" %>%
  wastdr::wastd_GET(api_url = prod) %>%
  wastdr::wastd_parse()

tsc_cons_cat <- "conservationcategory" %>%
  wastdr::wastd_GET(api_url = prod) %>%
  wastdr::wastd_parse() %>%
  dplyr::arrange(conservation_list, rank) %>%
  dplyr::left_join(tsc_cons_list, by = c("conservation_list" = "id"))

tsc_cons_crit <- "conservationcriterion" %>%
  wastdr::wastd_GET(api_url = prod) %>%
  wastdr::wastd_parse() %>%
  dplyr::arrange(conservation_list, rank) %>%
  dplyr::left_join(tsc_cons_list, by = c("conservation_list" = "id"))

tsc_cons_crit %>%
  dplyr::select(-"conservationcategory_set", -"conservationcriterion_set") %>%
  readr::write_csv(path = here::here("data", "tsc_conscrit.csv"))

# Load manual mapping of TFA cons criteria from CSV file, join to tfa_cons_crit
tfa_conscrit <- here::here("tfa_conscrit_w_tsc.csv") %>%
  readr::read_csv(
    col_types = cols(
      list_code = col_character(),
      tsc_criteria = col_character(),
      criteria_code = col_character(),
      assigned_as_in_tsc = col_character(),
      comments_MP = col_character(),
      actions = col_character()
    )
  ) %>%
  dplyr::mutate(
    tsc_criteria = purrr::map(tsc_criteria, chr2int)
  )

tfa_tcl <- tfa_cons_listings %>%
  left_join(tfa_conscrit, by = c("list_code", "criteria_code")) %>% glimpse
```

# Extract and transform occurrence lookup Data from TSC
``` {r extract_tsc_occurrence_lookup, message=FALSE}
tsc_landforms <- "lookup-landform" %>%
  wastdr::wastd_GET(api_url = prod) %>%
  wastdr::wastd_parse() %>%
  readr::write_csv(path = here::here("data", "tsc_landforms.csv"))

tsc_confidence <- "lookup-confidence" %>%
  wastdr::wastd_GET(api_url = prod) %>%
  wastdr::wastd_parse()
  
tsc_repro_mat <- "lookup-reproductivematurity" %>%
  wastdr::wastd_GET(api_url = prod) %>%
  wastdr::wastd_parse() %>%
  readr::write_csv(path = here::here("data", "tsc_repro_mat.csv"))

tsc_sec_signs <- "lookup-secondarysigns" %>%
  wastdr::wastd_GET(api_url = prod) %>%
  wastdr::wastd_parse() %>%
  readr::write_csv(path = here::here("data", "tsc_sec_signs.csv"))

tsc_samp_dest <- "lookup-sampledestination" %>%
  wastdr::wastd_GET(api_url = prod) %>%
  wastdr::wastd_parse() %>%
  readr::write_csv(path = here::here("data", "tsc_samp_dest.csv"))

tsc_samp_type <- "lookup-sampletype" %>%
  wastdr::wastd_GET(api_url = prod) %>%
  wastdr::wastd_parse() %>%
  readr::write_csv(path = here::here("data", "tsc_samp_type.csv"))

tsc_det_meth <- "lookup-detectionmethod" %>%
  wastdr::wastd_GET(api_url = prod) %>%
  wastdr::wastd_parse() %>%
  readr::write_csv(path = here::here("data", "tsc_det_meth.csv"))

# Load manual mapping of TFA lookup criteria from CSV file, and join to relevant table
tfa_landcrit <- here::here("tfa_landcrit_w_tsc.csv") %>%
  readr::read_csv(
    col_types = cols(
      landform_id = col_character(),
      landform = col_character(),
      tsc_landform_id = col_character(),
      tsc_criteria = col_character()
    ))

tfa_hab_comp <- hab_comp %>%
  left_join(tfa_landcrit, by = c("landform_id")) %>%  
dplyr::select(source,source_id,tsc_landform_id) %>% 
dplyr::rename(landform = tsc_landform_id) %>% glimpse

tfa_confidence <- here::here("tfa_id_conf_w_tsc.csv") %>%
  readr::read_csv(
    col_types = cols(
      species_id_confidence = col_character(),
      tsc_species_id_confidence = col_character(),
      tsc_criteria = col_character()
    ))

tfa_det_meth <- here::here("tfa_detmeth_w_tsc.csv") %>%
  readr::read_csv(
    col_types = cols(
      detection_method = col_character(),
      tsc_detection_method = col_character(),
      tsc_criteria = col_character()
    ))

tfa_sec_sign <- here::here("tfa_secsign_w_tsc.csv") %>%
  readr::read_csv(
    col_types = cols(
      secondary_signs = col_character(),
      tsc_secondary_signs = col_character(),
      tsc_criteria = col_character()
    ))

tfa_repmap <- here::here("tfa_repmat_w_tsc.csv") %>%
  readr::read_csv(
    col_types = cols(
      reproductive_maturity = col_character(),
      tsc_reproductive_maturity = col_character(),
      tsc_criteria = col_character()
    ))

names(anim_obs)

tfa_anim_obs <- anim_obs %>%
  left_join(tfa_confidence, by = c("species_id_confidence")) %>% 
  left_join(tfa_det_meth, by = c("detection_method")) %>%
  left_join(tfa_sec_sign, by = c("secondary_signs")) %>%
  left_join(tfa_repmap, by = c("reproductive_maturity")) %>%
dplyr::select(source,source_id,tsc_species_id_confidence,observation_details,tsc_detection_method,
              tsc_reproductive_maturity,tsc_secondary_signs,distinctive_features,number_of_adult_males,
              number_of_adult_females,number_of_adult_unknown,number_of_juvenile_males,number_of_juvenile_females,
              number_of_juvenile_unknown) %>%
  dplyr::rename(species_id_confidence = tsc_species_id_confidence) %>%
  dplyr::rename(detection_method = tsc_detection_method) %>%
  dplyr::rename(reproductive_maturity = tsc_reproductive_maturity) %>%
  dplyr::rename(secondary_signs = tsc_secondary_signs) %>% glimpse

tfa_samptype <- here::here("tfa_samptype_w_tsc.csv") %>%
  readr::read_csv(
    col_types = cols(
      sample_type = col_character(),
      tsc_sample_type = col_character(),
      tsc_criteria = col_character()
    ))

tfa_sampdest <- here::here("tfa_sampdest_w_tsc.csv") %>%
  readr::read_csv(
    col_types = cols(
      sample_destination = col_character(),
      tsc_sample_destination = col_character(),
      tsc_criteria = col_character()
    ))

names(phys_sample)

tfa_phys_sample <- phys_sample %>%
  left_join(tfa_samptype, by = c("sample_type")) %>% 
  left_join(tfa_sampdest, by = c("sample_destination")) %>%
dplyr::select(source,source_id,tsc_sample_type,specimen_voucher_exists,tsc_sample_destination,sample_label) %>%
  dplyr::rename(sample_type = tsc_sample_type) %>%
  dplyr::rename(sample_destination = tsc_sample_destination) %>% glimpse

tfa_veg_class <- veg_class %>% 
  dplyr::transmute(
    source = source,
    source_id = source_id,
    vegetation_classification = glue::glue(
        "{vegetation_code}; {vegetation_type}"))
```

# Load legacy data from TFA into TSC
In this section, the extracted and transformed data from TFA are loaded into TSC
using the TSC API. The code is collapsed; expand the code blocks to view the 
process.

## Taxonomy
Taxonomic names are uploaded to TSC directly from WACensus in a separate workbook.
The QA part of this workbook will compare TFA names to TSC names.

## Conservation listings
This section loads conservation listings from TFA into TSC.

Conservation listings are entered in triplicate:

Level 1: Legislation

* WAWCA is the WA Wildlife Conservation Act, the legistation under which taxa 
  can be gazetted as specially protected.
* WAWCA has been superseded by the Biodiversity Conservation Act 2016 on 01/01/2019.
* All conservation listings were/are gazetted under the respective act (WAWCA or BCA).

Level 2: Gazette

* SPFN = "Wildlife Conservation (Specially Protected Fauna) Notice, Schedules"
* SPFN are the gazetted schedules.

Level 3: Assigned conservation categories and criteria

* DBCA has assigned actual conservation cat&crit to taxa following the IUCN definitions, 
  or similar cat&crit of own design before IUCN was published.
* These "IUCN" cons listings are the actual listings we want to preserve.

In future, only IUCN 2012 cat&crit will be assigned to taxa.
The list of all listed taxa will be published by the government gazette annually, 
which will set the life cycle status of our IUN listings to "gazetted".
The underlying legislation (from now on, the BCA) is evident out of the context 
and does not have to be entered as conservation listing into TSC.

ETL decisions for Fauna cons listings:

* Fauna WAPF = TSC WAPS = Priority species.
* Fauna RedList = TSC IUCN 2012 (or whichever earlier version was applicable 
  at the time).
* Fauna ActionPlan was decided to be discarded.
* Fauna has three empty listings (no list, no cat, no crit) - discard.

```{r tfa_cons_listing_subsetting}
# tsc_conscat$id is the TSC ID for the cons category
# tsc_conscat$label = tec_cons_listing_categories$category_code
tsc_conscat_sp <- "conservationcategory" %>%
  wastdr::wastd_GET(api_url = prod) %>%
  magrittr::extract2("features") %>%
  {
    tibble::tibble(
      tsc_category_id = purrr::map_int(., "id"),
      category_code = purrr::map_chr(., "code"),
      tsc_label = purrr::map_chr(., "label"),
      conservation_list = purrr::map_chr(., "conservation_list")
    )
  } %>%
  dplyr::filter(conservation_list %in% 1:7)

# IUCN 2012 3
tfa_listing_cat_iucn2012 <- tfa_tcl %>%
  dplyr::filter(list_code == "IUCN(2012)") %>%
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 3),
    by = "category_code"
  ) %>%
  dplyr::transmute(
    source = 1, # TaxonGaz.source TFA
    source_id = source_id %>% as.character(),
    scope = 0,
    status = ifelse(is.na(delisted_on), 80, 90),
    effective_from = gazetted_on,
    effective_to = delisted_on,
    last_reviewed_on = last_reviewed_on,
    taxon = name_id %>% as.numeric(),
    category = tsc_category_id %>% as.list(),
    criteria = tsc_criteria,
    comments = glue::glue(
      "Reviewed by {reviewed_by}\n\n",
      "Review outcome: {review_outcome}\n\n",
      "Comments: {comments}"
    )
  ) %>%
  dplyr::filter(!is.na(category)) %>%
  dplyr::filter(taxon != 0)

# IUCN(2001) 4
tfa_listing_cat_iucn2001 <- tfa_tcl %>%
  dplyr::filter(list_code == "IUCN(2001)") %>%
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 4),
    by = "category_code"
  ) %>%
  dplyr::transmute(
    source = 1, # TaxonGaz.source TFA
    source_id = source_id %>% as.character(),
    scope = 0,
    status = ifelse(is.na(delisted_on), 80, 90),
    effective_from = gazetted_on,
    effective_to = delisted_on,
    last_reviewed_on = last_reviewed_on,
    taxon = name_id %>% as.numeric(),
    category = tsc_category_id %>% as.list(),
    criteria = tsc_criteria,
    comments = glue::glue(
      "Reviewed by {reviewed_by}\n\n",
      "Review outcome: {review_outcome}\n\n",
      "Comments: {comments}"
    )
  ) %>%
  dplyr::filter(!is.na(category)) %>%
  dplyr::filter(taxon != 0)

# IUCN(1994) 5
tfa_listing_cat_iucn1994 <- tfa_tcl %>%
  dplyr::filter(list_code == "IUCN(1994)") %>%
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 5),
    by = "category_code"
  ) %>%
  dplyr::transmute(
    source = 1, # TaxonGaz.source TFA
    source_id = source_id %>% as.character(),
    scope = 0,
    status = ifelse(is.na(delisted_on), 80, 90),
    effective_from = gazetted_on,
    effective_to = delisted_on,
    last_reviewed_on = last_reviewed_on,
    taxon = name_id %>% as.numeric(),
    category = tsc_category_id %>% as.list(),
    criteria = tsc_criteria,
    comments = glue::glue(
      "Reviewed by {reviewed_by}\n\n",
      "Review outcome: {review_outcome}\n\n",
      "Comments: {comments}"
    )
  ) %>%
  dplyr::filter(!is.na(category)) %>%
  dplyr::filter(taxon != 0)

# WAWCA 1
tfa_listing_cat_wawca <- tfa_tcl %>%
  dplyr::filter(list_code == "WAWCA") %>%
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 1),
    by = "category_code"
  ) %>%
  dplyr::transmute(
    source = 1, # TaxonGaz.source TFA
    source_id = source_id %>% as.character(),
    scope = 0,
    status = ifelse(is.na(delisted_on), 80, 90),
    effective_from = gazetted_on,
    effective_to = delisted_on,
    last_reviewed_on = last_reviewed_on,
    taxon = name_id %>% as.numeric(),
    category = tsc_category_id %>% as.list(),
    criteria = tsc_criteria,
    comments = glue::glue(
      "Reviewed by {reviewed_by}\n\n",
      "Review outcome: {review_outcome}\n\n",
      "Comments: {comments}"
    )
  ) %>%
  dplyr::filter(!is.na(category)) %>%
  dplyr::filter(taxon != 0)

# SPFN 2
tfa_listing_cat_spfn <- tfa_tcl %>%
  dplyr::filter(list_code == "SPFN") %>%
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 2),
    by = "category_code"
  ) %>%
  dplyr::transmute(
    source = 1, # TaxonGaz.source TFA
    source_id = source_id %>% as.character(),
    scope = 0,
    status = ifelse(is.na(delisted_on), 80, 90),
    effective_from = gazetted_on,
    effective_to = delisted_on,
    last_reviewed_on = last_reviewed_on,
    taxon = name_id %>% as.numeric(),
    category = tsc_category_id %>% as.list(),
    criteria = tsc_criteria,
    comments = glue::glue(
      "Reviewed by {reviewed_by}\n\n",
      "Review outcome: {review_outcome}\n\n",
      "Comments: {comments}"
    )
  ) %>%
  dplyr::filter(!is.na(category)) %>%
  dplyr::filter(taxon != 0)

# WAPS 6
tfa_listing_cat_waps <- tfa_tcl %>%
  dplyr::filter(list_code == "WAPF") %>%
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 6),
    by = "category_code"
  ) %>%
  dplyr::transmute(
    source = 1, # TaxonGaz.source TFA
    source_id = source_id %>% as.character(),
    scope = 0,
    status = ifelse(is.na(delisted_on), 80, 90),
    effective_from = gazetted_on,
    effective_to = delisted_on,
    last_reviewed_on = last_reviewed_on,
    taxon = name_id %>% as.numeric(),
    category = tsc_category_id %>% as.list(),
    criteria = tsc_criteria,
    comments = glue::glue(
      "Reviewed by {reviewed_by}\n\n",
      "Review outcome: {review_outcome}\n\n",
      "Comments: {comments}"
    )
  ) %>%
  dplyr::filter(!is.na(category)) %>%
  dplyr::filter(taxon != 0)

# EPBC 7
tfa_listing_cat_epbc <- tfa_tcl %>%
  dplyr::filter(list_code == "EPBC") %>%
  dplyr::left_join(dplyr::filter(tsc_conscat_sp, conservation_list == 7),
    by = "category_code"
  ) %>%
  dplyr::transmute(
    source = 1, # TaxonGaz.source TFA
    source_id = source_id %>% as.character(),
    scope = 1,
    status = ifelse(is.na(delisted_on), 80, 90),
    effective_from = gazetted_on,
    effective_to = delisted_on,
    last_reviewed_on = last_reviewed_on,
    taxon = name_id %>% as.numeric(),
    category = tsc_category_id %>% as.list(),
    criteria = tsc_criteria,
    comments = glue::glue(
      "Reviewed by {reviewed_by}\n\n",
      "Review outcome: {review_outcome}\n\n",
      "Comments: {comments}"
    )
  ) %>%
  dplyr::filter(!is.na(category)) %>%
  dplyr::filter(taxon != 0)
```


```{r tfa_cons_listing_upload, eval=F}
tfa_listing_cat_iucn2012 %>%
  wastdr::wastd_POST("taxon-conservationlisting", api_url = prod)

tfa_listing_cat_iucn2001 %>%
  wastdr::wastd_POST("taxon-conservationlisting", api_url = prod)

tfa_listing_cat_iucn1994 %>%
  wastdr::wastd_POST("taxon-conservationlisting", api_url = prod)

tfa_listing_cat_wawca %>%
  wastdr::wastd_POST("taxon-conservationlisting", api_url = prod)

tfa_listing_cat_spfn %>%
  wastdr::wastd_POST("taxon-conservationlisting", api_url = prod)

tfa_listing_cat_waps %>%
  wastdr::wastd_POST("taxon-conservationlisting", api_url = prod)

tfa_listing_cat_epbc %>%
  wastdr::wastd_POST("taxon-conservationlisting", api_url = prod)

# Expire cached TSC TCL
if (file.exists(datafile_tsc_fauna)) {fs::file_delete(datafile_tsc_fauna)}
```

## Occurrences

The EOO (Extent of occurance) is calculated as the convex hull around all recorded fauna occurances, including fossil records.
For further details on the methodology behind the movement of EOO data, please follow the link to the workbook.

### TSC upload example for EOOs

```{r ex_upload_one_eoo, eval=F}
one_taxon_eoo <- tibble::tibble(
  name_id = 24162,
  eoo = eoo_polygon(tfa_occ, nid = 24162) %>% sfc_geojson()
)
wastdr::wastd_POST(one_taxon_eoo, "taxon", verbose = T)
```

### Upload EOOs

```{r prepare eoo, eval=F}
# extract all eoo
fna <- tfa_occ %>% 
  dplyr::filter(!is.na(latitude)) %>% 
  dplyr::filter(!is.na(longitude))
fna_eoo_all <- eoo_polygon(fna)
# mapview::mapview(fna_eoo_all)

# Calculate_eoo
tfa_eoo <- fna %>% make_eoo()

# map_eoo
# mapview::mapview(head(fauna_eoo$eoo_sfc))
```

```{r upload_eoo, eval=F}
tfa_eoo %>%
  dplyr::select(-data, -eoo_sfc) %>%
  wastdr::wastd_POST("taxon", verbose = T, api_url = prod)
```


### Upload taxon area encounters
A single record (taxon area encounter), or a list of (one or) many records, can be uploaded to the TSC API as follows.

```{r fauna_single_occ, eval=F}
# 25757
taxonpoint = rjson::fromJSON('[{"taxon": 25757, "code": "Condingup", "description": "Pine plantations off Fisheries Rd east of Condinup\nOpportunistic sighting\nDay sighting\nHeard/Call\nSaw a flock of approximately 200 birds in the pine plantation\nObserved by Abby Thomas, DBCA Technical Officer, Albany",    "source": 10,    "source_id": "94654",    "encountered_on": "2018-04-16T15:00:00+08:00",    "encountered_by": 1,  "encounter_type":1,  "area_type": 30,    "accuracy": 1000.0,    "point":"SRID=4326;POINT(119.732234 -32.35756)"}]')
wastdr::wastd_POST(taxonpoint, serializer = "occ-taxon-points", verbose = T, api_url = prod)
```

```{r, eval = FALSE}
tfa_tae[1:100,] %>% chunk_post(serializer = "occ-taxon-points", verbose = T, api_url = prod)

tfa_tae[1:1000,] %>% chunk_post(serializer = "occ-taxon-points", verbose = T, api_url = prod)

tfa_tae %>% chunk_post(serializer = "occ-taxon-points", verbose = T, api_url = prod) # upload for all occurances
```
## Conservation Documents

## Fire History

## Conservation Threats and Actions


# Extract and transform migrated Data from TSC
Data from TSC is extracted through the TSC API and transformed into a usable
format.

Expand the code block below to view the process.

```{r load_tsc, message=FALSE}
# WACensus is the upstream source of taxonomic names
wace_names <- "public:herbie_hbvnames_public" %>%
  gs_getFeature() %>%
  magrittr::extract2("features") %>%
  {
    tibble::tibble(
      name_id = purrr::map(., c("properties", "name_id")) %>% flatten_chr(),
      wace_name = purrr::map(., c("properties", "name")) %>% flatten_chr()
    )
  }
# readr::write_csv(wace_names,path = here::here("data","wace_names.csv"))

tfa_species_nid <- species %>%
  dplyr::left_join(wace_names, by = "name_id")
tfa_species_name <- species %>%
  dplyr::left_join(wace_names, by = c("scientific_name" = "wace_name"))

# Taxonomic names and taxon conservation listings for fauna from TSC
if (file.exists(datafile_tsc_fauna)) {
  load(datafile_tsc_fauna)
} else {
  # TSC contains taxonomic names from WACensus
  tsc_taxa_fauna <- "taxon" %>%
    wastdr::wastd_GET(api_url = prod,
                      query = list(paraphyletic_groups__icontains = 20)) %>%
    wastdr::wastd_parse() %>%
    dplyr::mutate(name_id = name_id %>% as.character())
  
  # Taxon conservation listings for fauna
  tsc_tcl_fauna <-
    wastdr::wastd_GET("taxon-conservationlisting") %>%
    wastdr::parse_taxon_conservationlisting() %>%
    dplyr::mutate(name_id = taxon %>% as.character()) %>%
    dplyr::inner_join(tsc_taxa_fauna, by = "name_id")
  
  save(tsc_taxa_fauna, tsc_tcl_fauna, file = datafile_tsc_fauna)
}
```

# Compare legacy from TFA to migrated data from TSC
This section provides an automated comparison between original data from TFA 
and TFA data as uploaded into TSC. 

Data custodians should be able to comprehend this section, and be able to verify 
that the data migration has worked correctly.

Legacy data snapshot used for TFA was updated last on `r snapshot_last_updated`.

## Taxonomy

This section QAs taxonomy.

* TFA contains manually updated names from WACensus, plus new phrase names.
* TSC contains a synchronised copy of WACensus names.
* TSC contains all WACensus names. 
* TFA contains most but not all WACensus animal names.
* TFA is mapped to TSC via NameID.
* This section analyses whether the names match the NameID between TFA and
  WACensus.


### Name mismatches
For a given NameID, the scientific name in TFA should be identical to 
the scientific name in WACensus with the same NameID. 
A name mismatch is an indication for review.

```{r wacensus_names}
tfa_data_wacensus <- species_names %>%
  dplyr::left_join(wace_names, by = "name_id")
```

```{r wacensus_name_mismatch}
name_mismatches <- tfa_data_wacensus %>%
  dplyr::filter(scientific_name != wace_name) %>%
  dplyr::select(name_id, species_code, scientific_name, wace_name)
```

#### Mismatches containing "subsp"
WACensus names contain "subsp." whereas TFA don't. 
Therefore, scientific name mismatches by only the "subsp" can be ignored.

**QA** Review this list to make sure both WACensus and TFA mean the same name.
If the TFA "scientific_name" means a different taxon than the "wace_name", TFA's
NameID must be changed to the WACensus NameID of the correct taxon.

```{r name_mismatches_subsp}
name_mismatches %>%
  dplyr::filter(grepl("subsp", wace_name)) %>%
  reactable::reactable(filterable = TRUE)
```

#### Typo mismatches
The remaining mismatches contain minor differences, such as "sp." vs "sp", 
parentheses and quotation marks.

```{r name_mismatches_typo}
name_mismatches %>%
  dplyr::filter(!grepl("subsp", wace_name)) %>%
  reactable::reactable(filterable = TRUE)
```

#### True mismatches
The remaining mismatches require a review of the scientific name or NameID in TFA.

**QA** If the TFA "scientific_name" is meant to refer to a different taxon than 
the "wace_name", TFA's NameID must be changed to the WACensus NameID of the 
correct taxon.

```{r name_mismatches_real}
drop_cruft <- . %>%
  stringr::str_remove_all("[.()'\"]|sp|subsp") %>%
  stringr::str_replace_all("  ", " ")

true_mismatches <- tfa_data_wacensus %>%
  dplyr::mutate(
    scientific_name = scientific_name %>% drop_cruft(),
    wace_name = wace_name %>% drop_cruft()
  ) %>%
  dplyr::filter(scientific_name != wace_name) %>%
  dplyr::select(name_id, species_code, scientific_name, wace_name)

true_mismatches %>%
  reactable::reactable(filterable = TRUE)
```

### Names in TFA but not in TSC
Since TSC contains all WACensus names, all names in TFA with a NameID other 
than 0 (indicating a phrase name) should also occur in TSC.

Any records in the following table require review.

```{r species_mismatches}
# names_in_tfa_not_in_tsc
species_names %>%
  anti_join(tsc_taxa_fauna, by = "name_id") %>%
  reactable::reactable(filterable = TRUE)
```

### Names in TSC but not in TFA
There are more names in TSC that are not in TFA, as TSC maintains a full copy
of WACensus, whereas TFA only contains names it actually needs.

Records in the following table require no action, but are shown here for 
completeness.

```{r}
# names_in_tsc_not_in_tfa
tsc_taxa_fauna %>%
  anti_join(species_names, by = "name_id") %>%
  reactable::reactable(filterable = TRUE)
```

## Conservation Listing

```{r}
# General note: variable names should now be recycled like tfa_data
tfa_tcl_edit <- tfa_tcl %>%
  dplyr::filter(list_code != "ActionPlan") %>%
  dplyr::filter(list_code != "BCA") %>%
  dplyr::filter(list_code != "RedList") %>%
  dplyr::mutate(source_id = source_id %>% as.character())

tfa_tcl_unique_taxa <- tfa_tcl_edit$name_id %>%
  unique() %>%
  length()
tsc_tcl_unique_taxa <- tsc_tcl_fauna$name_id %>%
  unique() %>%
  length()
```

TFA has `r nrow(tfa_tcl_edit)` conservation listings of `r tfa_tcl_unique_taxa`.
TSC has `r nrow(tsc_tcl_fauna)` fauna conservation listings of 
`r tsc_tcl_unique_taxa`, including animals but excluding plants *sensu latu*.

### TFA conservation listings not in TSC

Any records in the following table indicate conservation listings in TFA that
were not migrated into TSC. The species listed were likely not migrated because they do not contain list_codes or category_codes.

Already excluded are conservation listings from the excluded categories 
"ActionPlan", "RedList", and "BCA".

```{r missing_observations}
tfa_tcl_edit %>%
  dplyr::anti_join(tsc_tcl_fauna, by = "source_id") %>%
  reactable::reactable(filterable = TRUE)
```

### TSC conservation listings not in TFA

The following table shows any conservation listings in TSC which are not in TFA.


```{r}
tsc_tcl_fauna %>%
  dplyr::anti_join(tfa_tcl_edit, by = "source_id") %>%
  reactable::reactable(filterable = TRUE)
```


### TFA cons listed phrase names
Some TFA cons listings have a name_id of 0. 
These are phrase names and require to be assigned the `name_id` of the published 
name, once the published name is known and entered into WACensus, then propagated
into TSC.

```{r}
tfa_tcl_edit %>% dplyr::filter(name_id == 0)
```

### TFA unmigrated conservation listings
ActionPlan (a book), the IUCN RedList (accessible online and via API), and BCA
listings (erroneous) are excluded from the data migration.

They are listed here.

```{r}
tfa_tcl %>%
  dplyr::filter(list_code == c("ActionPlan", "BCA", "RedList")) %>%
  reactable::reactable(filterable = TRUE)
```

### Conservation criteria mapping

Conservation criteria were manually mapped for each species, 
therefore they need to be checked to confirm whether the mapping is correct. 

```{r}
tfa_conscrit %>%
  reactable::reactable(filterable = TRUE)
```

In addition, some conservation criteria could not be mapped as they do not exist 
in the list/category_code. 
These need to be corrected before the manual mapping can be updated and the 
correct criteria assigned for all species.

### Conservation listing dates

Below are the dates of the most recent conservation criteria changes made in the
snapshot of the TFA.

Excluded are TFA cons listings of unmigrated lists (AP, RL, BCA).

``` {r effective_dates}
tsc_corner_dates <- tsc_tcl_fauna %>%
  summarise(
    effective_from_min = min(effective_from, na.rm = T),
    effective_from_max = max(effective_from, na.rm = T),
    effective_to_min = min(effective_to, na.rm = T),
    effective_to_max = max(effective_to, na.rm = T),
    last_reviewed_on_min = min(last_reviewed_on, na.rm = T),
    last_reviewed_on_max = max(last_reviewed_on, na.rm = T)
  )

tfa_corner_dates <- tfa_tcl_edit %>%
  summarise(
    effective_from_min = min(gazetted_on, na.rm = T),
    effective_from_max = max(gazetted_on, na.rm = T),
    effective_to_min = min(delisted_on, na.rm = T),
    effective_to_max = max(delisted_on, na.rm = T),
    last_reviewed_on_min = min(last_reviewed_on, na.rm = T),
    last_reviewed_on_max = max(last_reviewed_on, na.rm = T)
  )

cl_corner_dates <- rbind(tfa_corner_dates, tsc_corner_dates) %>%
  t() %>%
  magrittr::set_colnames(c("TFA", "TSC"))

cl_corner_dates %>% reactable::reactable()
```


### Conservation listing differences

Summary of the number of conservation listings for each list.

Discrepancies in numbers indicate the need for a closer review.

Equality of numbers does not prove absence of equal numbers of false positives
and false negatives.

```{r summary_conservation_list}

# TODO we probably want to use a tribble here
# https://tibble.tidyverse.org/reference/tribble.html
make_tfa_cl_summary <- . %>% nrow() %>% as.data.frame() %>% magrittr::set_colnames("TFA")

tfa_cl_sum_iucn1994 <- tfa_listing_cat_iucn1994 %>% make_tfa_cl_summary
tfa_cl_sum_iucn2001 <- tfa_listing_cat_iucn2001 %>% make_tfa_cl_summary
tfa_cl_sum_iucn2012 <- tfa_listing_cat_iucn2012 %>% make_tfa_cl_summary
tfa_cl_sum_wawca <- tfa_listing_cat_wawca %>% make_tfa_cl_summary
tfa_cl_sum_waps <- tfa_listing_cat_waps %>% make_tfa_cl_summary
tfa_cl_sum_spfn <- tfa_listing_cat_spfn %>% make_tfa_cl_summary
tfa_cl_sum_epbc <- tfa_listing_cat_epbc %>% make_tfa_cl_summary


make_tsc_cl_summary <- function(data, cn){
  data %>%
  dplyr::select(category_cache) %>%
  dplyr::filter(str_detect(category_cache, cn)) %>%
  nrow() %>% 
  as.data.frame %>% 
  magrittr::set_colnames("TSC")
}

tsc_cl_sum_iucn1994 <- tsc_tcl_fauna %>% make_tsc_cl_summary("IUCN1994")
tsc_cl_sum_iucn2001 <- tsc_tcl_fauna %>% make_tsc_cl_summary("IUCN2001")
tsc_cl_sum_iucn2012 <- tsc_tcl_fauna %>% make_tsc_cl_summary("IUCN2012")
tsc_cl_sum_wawca <- tsc_tcl_fauna %>% make_tsc_cl_summary("WAWCA")
tsc_cl_sum_waps <- tsc_tcl_fauna %>% make_tsc_cl_summary("WAPS")
tsc_cl_sum_spfn <- tsc_tcl_fauna %>% make_tsc_cl_summary("SPFN")
tsc_cl_sum_epbc <- tsc_tcl_fauna %>% make_tsc_cl_summary("EPBC")


tfa_cons_cat_sum <- rbind(
  tfa_cl_sum_iucn1994, 
  tfa_cl_sum_iucn2001, 
  tfa_cl_sum_iucn2012, 
  tfa_cl_sum_wawca, 
  tfa_cl_sum_waps,
  tfa_cl_sum_spfn, 
  tfa_cl_sum_epbc
)

tsc_cons_cat_sum <- rbind(
  tsc_cl_sum_iucn1994, 
  tsc_cl_sum_iucn2001, 
  tsc_cl_sum_iucn2012, 
  tsc_cl_sum_wawca, 
  tsc_cl_sum_waps,
  tsc_cl_sum_spfn, 
  tsc_cl_sum_epbc 
  )

cons_cat_summary <- tfa_cons_cat_sum %>%
  cbind(tsc_cons_cat_sum) %>%
  cbind(Category = c("IUCN1994", "IUCN2001", "IUCN2012", 
                     "WAWCA", "WAPS", "SPFN", "EPBC")) %>%
  dplyr::select("Category", everything())

cons_cat_summary %>% reactable::reactable()
```

The following tables show any conservation listings in TFA which are not in TSC, for each conservation list.

IUCN 2012
```{r }
#### IUCN 2012
tsc_listing_cat_iucn2012 <- tsc_tcl_fauna %>%
  dplyr::mutate(taxon = name_id %>% as.integer) %>% 
  dplyr::filter(str_detect(category_cache, "IUCN(2012)"))

tfa_listing_cat_iucn2012 %>% 
  dplyr::anti_join(tsc_listing_cat_iucn2012, by = "taxon") %>%
  reactable::reactable(filterable = T)
```
IUCN 2001
```{r}
#### IUCN 2001
tsc_listing_cat_iucn2001 <- tsc_tcl_fauna %>%
  dplyr::mutate(taxon = name_id %>% as.integer) %>% 
  dplyr::filter(str_detect(category_cache, "IUCN(2001)"))

tfa_listing_cat_iucn2001 %>% 
  dplyr::anti_join(tsc_listing_cat_iucn2001, by = "taxon") %>%
  reactable::reactable(filterable = T)
```
IUCN 1994
```{r}
#### IUCN 1994
tsc_listing_cat_iucn1994 <- tsc_tcl_fauna %>%
  dplyr::mutate(taxon = name_id %>% as.integer) %>% 
  dplyr::filter(str_detect(category_cache, "IUCN(1994)"))

tfa_listing_cat_iucn1994 %>% 
  dplyr::anti_join(tsc_listing_cat_iucn1994, by = "taxon") %>%
  reactable::reactable(filterable = T)
```
WAWCA
```{r}
#### WAWCA
tsc_listing_cat_wawca <- tsc_tcl_fauna %>%
  dplyr::mutate(taxon = name_id %>% as.integer) %>% 
  dplyr::filter(str_detect(category_cache, "WAWCA"))

tfa_listing_cat_wawca %>% 
  dplyr::anti_join(tsc_listing_cat_wawca, by = "taxon") %>%
  reactable::reactable(filterable = T)
```
WAPS
```{r}
#### WAPS
tsc_listing_cat_waps <- tsc_tcl_fauna %>%
  dplyr::mutate(taxon = name_id %>% as.integer) %>% 
  dplyr::filter(str_detect(category_cache, "WAPS"))

tfa_listing_cat_waps %>% 
  dplyr::anti_join(tsc_listing_cat_waps, by = "taxon") %>%
  reactable::reactable(filterable = T)
```
SPFN
```{r}
#### SPFN
tsc_listing_cat_spfn <- tsc_tcl_fauna %>%
  dplyr::mutate(taxon = name_id %>% as.integer) %>% 
  dplyr::filter(str_detect(category_cache, "SPFN"))

tfa_listing_cat_spfn %>% 
  dplyr::anti_join(tsc_listing_cat_spfn, by = "taxon") %>%
  reactable::reactable(filterable = T)
```
EPBC
```{r}
#### EPBC
tsc_listing_cat_epbc <- tsc_tcl_fauna %>%
  dplyr::mutate(taxon = name_id %>% as.integer) %>% 
  dplyr::filter(str_detect(category_cache, "EPBC"))

tfa_listing_cat_epbc %>% 
  dplyr::anti_join(tsc_listing_cat_epbc, by = "taxon") %>%
  reactable::reactable(filterable = T)
```

The following tables show any conservation listings in TSC which are not in TFA, for each conservation list.

IUCN 2012
```{r }
#### IUCN 2012
tsc_listing_cat_iucn2012 %>%
  dplyr::anti_join(tfa_listing_cat_iucn2012, by = "taxon") %>%
  reactable::reactable(filterable = T)
```
IUCN 2001
```{r}
#### IUCN 2001
tsc_listing_cat_iucn2001 %>% 
  dplyr::anti_join(tfa_listing_cat_iucn2001,by = "taxon") %>% 
  reactable::reactable(filterable = T)
```
IUCN 1994
```{r}
#### IUCN 1994
tsc_listing_cat_iucn1994 %>% 
  dplyr::anti_join(tfa_listing_cat_iucn1994,by = "taxon") %>% 
  reactable::reactable(filterable = T)
```
WAWCA
```{r}
#### WAWCA
tsc_listing_cat_wawca %>% 
  dplyr::anti_join(tfa_listing_cat_wawca,by = "taxon") %>% 
  reactable::reactable(filterable = T)
```
WAPS
```{r}
#### WAPS
tsc_listing_cat_waps %>% 
  dplyr::anti_join(tfa_listing_cat_waps,by = "taxon") %>% 
  reactable::reactable(filterable = T)
```
SPFN
```{r}
#### SPFN
tsc_listing_cat_spfn %>% 
  dplyr::anti_join(tfa_listing_cat_spfn,by = "taxon") %>% 
  reactable::reactable(filterable = T)
```
EPBC
```{r}
#### EPBC
tsc_listing_cat_epbc %>% 
  dplyr::anti_join(tfa_listing_cat_epbc,by = "taxon") %>% 
  reactable::reactable(filterable = T)
```

## Occurrences

There are `r nrow(tfa_occ)` species occurrence records (encounters)in TFA. 
The following columns are incomplete.

```{r fauna_missing_values}
tfa_skim <- tfa_occ %>% skimr::skim()

tfa_skim %>%
  filter(n_missing > 0) %>%
  # select(-stat, -level, -formatted) %>%
  reactable::reactable(filterable = TRUE)

# Big Fauna: taxa with a lot of sightings
tfa_tae_big <- tfa_tae %>% dplyr::group_by(taxon) %>% dplyr::tally() %>% dplyr::arrange(-n) %>% filter(n>400) %>% ungroup()
```

#### Taxonomic caveats
Fauna occurrences link to the name that was current / legal at the time.
Occurrence query should show hints linking to current / legal names and their history.

`zone` and `datum` are standard names expected by BioSys.

#### Date/ Location caveats
This section lists data issues which need to be fixed at the source (here, in legacy TFA).

The column `datetime` is required in BioSys to be populated.
R generates `NA` where datetime is missing, but BioSys can't handle `NA` strings.

Where a time is missing, we'll default to midnight (00:00).
Where a date is missing, we'll default to 1900-01-01.

While this modifies the original data, the consequences will not have a dramatic effect on analyses for
conservation management purposes:

* A safe default of the observation time (midnight) could introduce an error of up to one day. 
  Compared to the time frame considered (past 10-50 years of observations relative to time of 
  calculation), this error is minuscule.
* A safe default for missing dates (1900-01-01) will both exclude those observations from any recent
  observations (past 10-50 years), but still make the data available to identify the records for the
  purpose of backfilling a credible date.

Please review legacy data until the following numbers are all zero (or accept default handling):

* `r tfa_occ %>% dplyr::filter(is.na(datetime)) %>% nrow()` datetimes couldn't be restored and require
  a valid date (and ideally time) to be set at the source.
* `r tfa_occ %>% dplyr::filter(orig_time == "") %>% nrow()` records lack an explicit time and were 
  defaulted to midnight AWST.
* `r tfa_occ %>% dplyr::filter(orig_date == "") %>% nrow()` records lack an explicit date and were
  defaulted to 1900-01-01.
* `r tfa_occ %>% dplyr::filter(is.na(latitude)) %>% nrow` latitudes are missing.
* `r tfa_occ %>% dplyr::filter(is.na(longitude)) %>% nrow` longitudes are missing.
* `r tfa_occ %>% dplyr::filter(latitude > 0) %>% nrow` latitudes lack the minus sign and turn up in China.

#### Missing NameID
```{r missing_name_id}
tfa_occ_no_nameid <- tfa_occ %>% 
    filter(name_id == 0) %>% 
    select(scientific_name) %>% 
    unique()
tfa_occ_no_nameid %>% reactable::reactable()
```
There are `r nrow(tfa_occ_no_nameid)` distinct scientific fauna names missing a NameID.

#### Missing Species Code
```{r missing_species_code}
tfa_occ_no_specode <- tfa_occ %>% 
    filter(species_code == 0) %>% 
    select(scientific_name) %>% 
    unique()
tfa_occ_no_nameid %>% reactable::reactable()
```
There are `r nrow(tfa_occ_no_specode)` distinct scientific fauna names missing a Species Code.
Any records listed here need to be fixed in the original Threatened Fauna database.

#### Default/ missing dates
```{r missing dates}
tfa_occ_no_date<- tfa_occ %>% 
    filter(o_date == "1900-01-01")
tfa_occ_no_date %>% reactable::reactable()
```
There are `r nrow(tfa_occ_no_date)` distinct scientific fauna names missing a date.

#### Default/ missing times
```{r missing times}
tfa_occ_no_time<- tfa_occ %>% 
    filter(o_time == "1900-01-01 00:00:00")
tfa_occ_no_time %>% reactable::reactable()
```
There are `r nrow(tfa_occ_no_time)` distinct scientific fauna names missing a time.

#### Missing coordinates
```{r missing coordinates}
tfa_occ_no_latlng <- tfa_occ %>% 
    filter(is.na(latitude) | is.na(longitude))
tfa_occ_no_latlng %>% reactable::reactable()
```

There are `r nrow(tfa_occ_no_latlng)` distinct fauna records with missing latitude or longitude.

```{r has eastnorthings}
tfa_occ_no_latlng_w_ne <- tfa_occ %>% 
  filter(is.na(latitude) | is.na(longitude)) %>% 
  filter((northing != "NA") | (easting!= "NA"))
tfa_occ_no_latlng_w_ne %>% reactable::reactable()
```

There are `r nrow(tfa_occ_no_latlng_w_ne)` distinct fauna records with missing latitude or longitude, which have northings and eastings.

#### Datum
```{r datum_tally}
datum_tally <- tfa_occ %>%
  dplyr::group_by(datum) %>%
  dplyr::tally() %>%
  dplyr::arrange(desc(n)) %>% 
  ungroup()
datum_tally %>% reactable::reactable()
```

There are `r nrow(datum_tally)` different datums used across all distinct fauna records. 

```{r datum_blank}
datum_blank<- tfa_occ %>% 
    filter(datum == "")
```

There are `r nrow(datum_blank)` distinct fauna records with missing datum. These will be defaulted to WGS84.

#### NameID mismatch
TODO diagnose. Lookup scientific names in TSC, get name_id, compare to name_id here.

#### Trust level of occurrence records
Currently, we assume that all occurrence records in the legacy databases are trustworthy.
If this weren't the case, this analysis should exclude the non-trustworthy records.

### TFA occurances not in TSC
```{r tally_tfa_occ}
tfa_tally <- tfa_occ %>%
  dplyr::group_by(name_id, scientific_name) %>% 
  dplyr::tally() %>%
  dplyr::arrange(desc(n)) %>% 
  ungroup()
tfa_tally %>% reactable::reactable()

tfa_tally_top <- tfa_tally %>% 
  top_n(20,n)

tfa_tally_btm <- tfa_tally %>% 
  top_n(20,-n) %>% 
  slice(1:20) # There are actually 151 species with an occurance of 1
```

There are `r nrow(tfa_tally)` fauna taxa with occurrences in TFA.

TODO Once we have data out of TSC compare tally of occurances for top 20 and bottom 20 species

### TSC occurrences not in TFA

```{r tally_tsc_occ,eval=FALSE}
tsc_tally <- tsc_occ %>%
  dplyr::group_by(name_id, scientific_name) %>% 
  dplyr::tally() %>%
  dplyr::arrange(desc(n)) %>% 
  ungroup()
tsc_tally %>% reactable::reactable()

tsc_tally_top <- tsc_tally %>% 
  top_n(20,n)

tsc_tally_btm <- tsc_tally %>% 
  top_n(20,-n) %>% 
  slice(1:20) # There are actually 151 species with an occurance of 1
```

## TFA occurrences not in TAE
```{r tally_tfa_tae}
tae_tally <- tfa_tae %>%
  dplyr::group_by(taxon) %>% 
  dplyr::tally() %>%
  dplyr::arrange(desc(n)) %>% 
  ungroup() %>% 
  dplyr::rename(name_id = taxon)

tae_tally_top <- tae_tally %>% 
  top_n(20,n)

tae_tally_btm <- tae_tally %>% 
  top_n(20,-n) %>% 
  slice(1:20) # There are actually 151 species with an occurance of 1

missing_species <- tae_tally %>% anti_join(tfa_tally,by = "name_id")

tfa_tally %>%
  dplyr::rename(tfa = n) %>% 
  left_join(tae_tally,by = "name_id") %>% 
  dplyr::rename(tae = n) %>% 
  filter(tfa != tae) %>% reactable::reactable()
```

There are `r nrow(missing_species)` species missing from tfa_tae when compared to tfa_occ. 
One species has different numbers of occurrences between tfa_occ and tfa_tae, and another two species have their populations combined (see NOTE). 

** NOTE** In tfa_tae Ninox connivens and Ixobrychus flavicollis australis are their combined north and south subpops from tfa_occ.

```{r tally_tfa_possum}
tfa_possum <- tfa_occ %>% filter(name_id == 24166) 
tae_possum <- tfa_tae %>% filter(taxon == 24166)
tfa_possum %>% 
  anti_join(tae_possum,by = c("id"="source_id")) %>% reactable::reactable()
```
The two occurances above do not appear in tfa_tae because there is no lat or long data, which is a criteria for taxon area encounters

## Conservation Documents

## Fire History

## Conservation Threats and Actions

# Upload to data catalogue
The [compiled version of this workbook](https://data.dpaw.wa.gov.au/dataset/79e90d7b-33a3-4aa0-8634-8a12033eb21d/resource/2b136da7-35cf-44a5-b29e-9f568176b7ad/download/eda_fauna.html) is uploaded to the 
[Threatened Fauna Dataset](https://data.dpaw.wa.gov.au/dataset/threatened-and-priority-fauna-database/) 
on the DBCA data catalogue.

The manual mapping of conservation criteria, plus all legacy data is also
uploaded as CSV snapshots.

```{r upload_data_catalogue}
# This workbook
upload_file_to_ckan("2b136da7-35cf-44a5-b29e-9f568176b7ad", "EDA_fauna.html")

# Manual mapping of conservation criteria
upload_file_to_ckan("e1c3119b-f44d-4244-8915-21097bd16b90", 
                    here::here("tfa_conscrit_w_tsc.csv"))

# Legacy TFA data
d <- ckanr::package_show("threatened-and-priority-fauna-database")
upload_to_ckan(
  tfa_cons_listings, "Threatened Fauna Conservation Status Gazettal", d$id,
  resource_id = "ac089664-de5a-4efa-af3c-ada0ec77ef1f"
)
# same for other TFA legacy data, copy over from data_etl_fauna.Rmd
```
